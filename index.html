<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ClubWPT Gold – Preflop Ranges (Interactive)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#121c3f;
      --text:#e7ecff;
      --muted:#aab3d6;
      --border:#24305f;
      --raise:#24c26a;
      --call:#36a3ff;
      --fold:#ff4d5a;
      --mix:#f6c445;
      --cell:#0c1430;
      --cell2:#0b132b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 30% 10%, #152252 0%, var(--bg) 55%, #070a14 100%);
      color:var(--text);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:22px}
    .hdr{display:flex;gap:14px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap}
    .title{
      display:flex;flex-direction:column;gap:6px
    }
    h1{font-size:20px;margin:0;font-weight:800;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:13px;line-height:1.35}

    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    select, button{
      background: linear-gradient(180deg, #0b132b, #0f1733);
      color:#e7ecff;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      font-size:13px;
      outline:none;
    }
    button{cursor:pointer}
    button:hover{filter:brightness(1.08)}

    .gridWrap{margin-top:16px;display:grid;grid-template-columns: 1fr 280px;gap:14px;align-items:start}
    @media (max-width: 900px){
      .gridWrap{grid-template-columns: 1fr;}
    }

    .card{
      background: linear-gradient(180deg, rgba(18,28,63,.88), rgba(12,18,44,.88));
      border:1px solid var(--border);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .cardHd{padding:14px 14px 10px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap}
    .cardHd .kicker{color:var(--muted);font-size:12px}

    .matrix{
      padding:12px;
      display:grid;
      grid-template-columns: 42px repeat(13, 1fr);
      gap:6px;
    }
    .hdrCell{
      height:32px;
      border-radius:10px;
      display:flex;align-items:center;justify-content:center;
      color:var(--muted);
      font-weight:700;
      font-size:12px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
    }

    .cell{
      position:relative;
      height:44px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(13,20,48,.95), rgba(10,16,38,.95));
      border:1px solid rgba(255,255,255,.07);
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, filter .06s ease;
    }
    .cell:hover{transform: translateY(-1px);filter:brightness(1.06)}

    .cell .hand{font-weight:800;font-size:13px;letter-spacing:.2px}
    .cell .act{
      position:absolute;bottom:6px;right:8px;
      font-size:10px;font-weight:800;opacity:.9
    }

    .act-raise{background: rgba(36,194,106,.14); border-color: rgba(36,194,106,.45)}
    .act-call{background: rgba(54,163,255,.14); border-color: rgba(54,163,255,.45)}
    .act-fold{background: rgba(255,77,90,.10); border-color: rgba(255,77,90,.35)}
    .act-mix{background: rgba(246,196,69,.12); border-color: rgba(246,196,69,.42)}

    .side{padding:14px}
    .legend{display:grid;gap:10px;margin-top:6px}
    .pill{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 12px;border-radius:14px;border:1px solid var(--border);background: rgba(255,255,255,.03)}
    .dot{width:12px;height:12px;border-radius:99px}
    .dot.raise{background:var(--raise)}
    .dot.call{background:var(--call)}
    .dot.fold{background:var(--fold)}
    .dot.mix{background:var(--mix)}
    .pill b{font-size:13px}
    .pill span{color:var(--muted);font-size:12px}

    .info{margin-top:14px;padding:12px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background: rgba(255,255,255,.03)}
    .info h3{margin:0 0 8px;font-size:13px}
    .kv{display:grid;grid-template-columns: 1fr 1fr;gap:8px}
    .kv div{padding:8px;border-radius:12px;background: rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)}
    .kv .k{color:var(--muted);font-size:11px}
    .kv .v{font-weight:800;font-size:13px;margin-top:2px}

    .footerNote{margin-top:14px;color:var(--muted);font-size:12px;line-height:1.4}

    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background: rgba(15,23,51,.95);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      box-shadow:0 14px 30px rgba(0,0,0,.35);
      opacity:0;pointer-events:none;
      transition: opacity .15s ease, transform .15s ease;
      font-size:13px;
      max-width:min(560px, calc(100vw - 22px));
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-3px)}

    .tag{
      padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size:11px;font-weight:800;
    }
  
    /* Trainer */
    .trainerPrompt{padding:12px 14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background: rgba(255,255,255,.03);font-weight:800;line-height:1.35}
    .trainerHandRow{display:flex;gap:14px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .trainerHand{font-size:34px;font-weight:950;letter-spacing:.6px;padding:12px 16px;border-radius:18px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.18);min-width:150px;text-align:center}
    .trainerBtns{display:flex;gap:10px;flex-wrap:wrap}
    .btnAct{padding:12px 14px;border-radius:14px;border:1px solid rgba(255,255,255,.10);font-weight:900;min-width:110px}
    .btnAct.raise{background: rgba(36,194,106,.14);border-color: rgba(36,194,106,.45)}
    .btnAct.call{background: rgba(54,163,255,.14);border-color: rgba(54,163,255,.45)}
    .btnAct.fold{background: rgba(255,77,90,.10);border-color: rgba(255,77,90,.35)}
    .btnAct:disabled{opacity:.55;cursor:not-allowed;filter:none}
    .trainerResult{padding:12px 14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background: rgba(255,255,255,.03)}
    .trainerResultTop{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .trainerBadge{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);font-size:11px;font-weight:950;letter-spacing:.4px}
    .trainerBadge.good{background: rgba(36,194,106,.14);border-color: rgba(36,194,106,.45)}
    .trainerBadge.bad{background: rgba(255,77,90,.12);border-color: rgba(255,77,90,.35)}
    .trainerBadge.mix{background: rgba(246,196,69,.12);border-color: rgba(246,196,69,.42)}
    .trainerExplain{margin-top:8px;color:var(--muted);font-size:12px;line-height:1.45;font-weight:700}


    .matrixScroll{overflow-x:auto; -webkit-overflow-scrolling:touch; padding-bottom:6px}
    .matrixScroll::-webkit-scrollbar{height:10px}
    .matrixScroll::-webkit-scrollbar-thumb{background: rgba(255,255,255,.10); border-radius:999px}

    /* Mobile sizing tweaks */
    @media (max-width: 520px){
      .wrap{padding:14px}
      .controls{width:100%}
      select, button{width:100%}
      .matrix{grid-template-columns: 34px repeat(13, minmax(26px, 1fr)); gap:5px; padding:10px}
      .cell{height:34px; border-radius:10px}
      .cell .hand{font-size:11px}
      .cell .act{display:none}
      .hdrCell{height:26px; border-radius:9px; font-size:11px}
      .trainerHand{font-size:28px; min-width:130px}
      .btnAct{min-width:96px; width:100%}
      .trainerBtns{width:100%}
      .trainerHandRow{gap:10px}
    }

    /* Trainer mini grid */
    .miniWrap{border:1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.02); border-radius:16px; padding:10px}
    .miniTitle{color:var(--muted); font-size:12px; font-weight:900; margin:2px 0 8px}
    .matrix.mini{grid-template-columns: 34px repeat(13, minmax(22px, 1fr)); gap:4px; padding:8px}
    .matrix.mini .cell{height:28px; border-radius:9px}
    .matrix.mini .cell .hand{font-size:10px}
    .matrix.mini .hdrCell{height:22px; border-radius:8px; font-size:10px}
    .cell.sel{outline: 3px solid rgba(255,255,255,.85); outline-offset: -2px}
    .cell.sel.good{outline-color: rgba(36,194,106,.95)}
    .cell.sel.bad{outline-color: rgba(255,77,90,.95)}

</style>
</head>
<body>
  <div class="wrap">
    <div class="hdr">
      <div class="title">
        <h1>ClubWPT Gold – Preflop Ranges (Interactive)</h1>
        <div class="sub">
          Built for <span class="tag">8-max</span> <span class="tag">$0.05/$0.10</span> <span class="tag">$0.05 ante</span> <span class="tag">4% rake (cap fast)</span> and typical <span class="tag">3–4x</span> opens.
          <br/>Tip: click any hand to see the action and why it’s there.
        </div>
      </div>
      <div class="controls">
        <select id="scenario"></select>
        <button id="toggleLabels">Hide action labels</button>
        <button id="copy">Copy current range as text</button>
        <button id="modeBtn">Trainer mode</button>
      </div>
    </div>

    <div id="explorerView" class="gridWrap">
      <div class="card">
        <div class="cardHd">
          <div>
            <div style="font-weight:900" id="scenarioTitle">—</div>
            <div class="kicker" id="scenarioKicker">—</div>
          </div>
          <div class="kicker" id="mixNote">Green = Raise/Open/3B • Blue = Call • Red = Fold • Yellow = Mix</div>
        </div>
        <div class="matrixScroll"><div class="matrix" id="matrix"></div></div>
      </div>

      <div class="card side">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div style="font-weight:900">Legend</div>
          <div class="kicker" id="rangePct">—</div>
        </div>
        <div class="legend">
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot raise"></div><b>Raise</b></div><span id="cntRaise">—</span></div>
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot call"></div><b>Call</b></div><span id="cntCall">—</span></div>
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot mix"></div><b>Mix</b></div><span id="cntMix">—</span></div>
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot fold"></div><b>Fold</b></div><span id="cntFold">—</span></div>
        </div>

        <div class="info">
          <h3>Selected Hand</h3>
          <div class="kv">
            <div><div class="k">Hand</div><div class="v" id="selHand">—</div></div>
            <div><div class="k">Action</div><div class="v" id="selAct">—</div></div>
            <div style="grid-column:1 / -1"><div class="k">Note</div><div class="v" id="selNote" style="font-size:12px;font-weight:700;color:var(--muted);line-height:1.35">Click a cell</div></div>
          </div>
        </div>

        <div class="footerNote">
          These are practical, rake-aware ranges (not solver-perfect). We can add more scenarios (ISO vs limps, 4-bets, squeeze, BB vs 4x, etc.) once you like the look/feel.
        </div>
      </div>
    </div>
  </div>

    <!-- Trainer View -->
    <div id="trainerView" class="gridWrap" style="display:none">
      <div class="card">
        <div class="cardHd">
          <div>
            <div style="font-weight:900">Trainer Mode</div>
            <div class="kicker" id="trainerKicker">Random spot + random hand. Choose the action you’d take.</div>
          </div>
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
            <select id="trainerScenario" title="Scenario"></select>
            <select id="trainerRandomness" title="Hand selection">
              <option value="all">All hands (uniform)</option>
              <option value="playable">Playable hands only (R/C/M)</option>
              <option value="edge">Focus mistakes (missed hands)</option>
            </select>
            <button id="trainerNext">Next</button>
          </div>
        </div>

        <div style="padding:16px;display:grid;gap:14px">
          <div class="trainerPrompt" id="trainerPrompt">—</div>

          <div class="miniWrap">
            <div class="miniTitle">Reference grid (current scenario)</div>
            <div class="matrixScroll"><div class="matrix mini" id="trainerMatrix"></div></div>
          </div>

          <div class="trainerHandRow">
            <div class="trainerHand" id="trainerHand">—</div>
            <div class="trainerBtns">
              <button class="btnAct raise" id="btnRaise">Raise</button>
              <button class="btnAct call" id="btnCall">Call</button>
              <button class="btnAct fold" id="btnFold">Fold</button>
            </div>
          </div>

          <div class="trainerResult" id="trainerResult" style="display:none">
            <div class="trainerResultTop">
              <div>
                <div class="kicker">Result</div>
                <div style="font-weight:900;font-size:16px" id="trainerResultTitle">—</div>
              </div>
              <div class="trainerBadge" id="trainerBadge">—</div>
            </div>
            <div class="trainerExplain" id="trainerExplain">—</div>
          </div>
        </div>
      </div>

      <div class="card side">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div style="font-weight:900">Stats</div>
          <div class="kicker" id="trainerSession">This session</div>
        </div>

        <div class="info" style="margin-top:10px">
          <div class="kv">
            <div><div class="k">Correct</div><div class="v" id="stCorrect">0</div></div>
            <div><div class="k">Total</div><div class="v" id="stTotal">0</div></div>
            <div><div class="k">Accuracy</div><div class="v" id="stAcc">0%</div></div>
            <div><div class="k">Streak</div><div class="v" id="stStreak">0</div></div>
            <div style="grid-column:1 / -1"><div class="k">Missed hands (recent)</div><div class="v" id="stMissed" style="font-size:12px;font-weight:700;color:var(--muted);line-height:1.35">—</div></div>
          </div>
        </div>

        <div class="footerNote">
          Tip: Start with “Playable hands only” to build intuition, then switch to “All hands” to eliminate leaks.
          <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap">
            <button id="trainerReset">Reset session</button>
            <button id="trainerClearHistory">Clear missed list</button>
          </div>
        </div>
      </div>
    </div>

  <div class="toast" id="toast"></div>

<script>
  const ranks = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];

  // Action codes
  const ACT = {
    R: {label:"RAISE", cls:"act-raise", color:"var(--raise)"},
    C: {label:"CALL",  cls:"act-call",  color:"var(--call)"},
    F: {label:"FOLD",  cls:"act-fold",  color:"var(--fold)"},
    M: {label:"MIX",   cls:"act-mix",   color:"var(--mix)"},
  };

  // --- Helper: expand shorthand specs into a 169-hand action map ---
  // We store rules as arrays of tokens:
  //  - Pair ranges: "22+", "TT+"
  //  - Suited ranges: "A2s+", "K9s+", "Q9s+", "J9s+", "T8s+", "97s+", "86s+"
  //  - Offsuit ranges: "ATo+", "KTo+", "QTo+", "JTo", "KJo+", "QJo", "AJo+"
  //  - Specific combos: "KQs", "AQo" etc.

  function rankIndex(r){ return ranks.indexOf(r); }

  function allHands(){
    const hands=[];
    for(let i=0;i<ranks.length;i++){
      for(let j=0;j<ranks.length;j++){
        const a=ranks[i], b=ranks[j];
        if(i===j) hands.push(a+b);
        else if(i<j) hands.push(a+b+"s");
        else hands.push(a+b+"o");
      }
    }
    return hands;
  }

  function inPairPlus(hand, startPair){
    // hand like "77"; startPair like "TT" means TT, JJ, QQ, KK, AA
    if(hand.length!==2 || hand[0]!==hand[1]) return false;
    const h=rankIndex(hand[0]);
    const s=rankIndex(startPair[0]);
    return h<=s; // A is index 0 (stronger), so <= means higher/equal strength
  }

  function expandPairPlus(token){
    const base=token.slice(0,2); // e.g. "22"
    const res=[];
    for(const r of ranks){
      const h=r+r;
      if(inPairPlus(h, base)) res.push(h);
    }
    return res;
  }

  function expandSuitedPlus(token){
    // e.g. "A7s+" => A7s..A2s? careful: plus means stronger kicker (closer to A)
    // We'll interpret as: same first rank, second rank from given up to (but not including first rank)
    const a=token[0];
    const b=token[1];
    const res=[];
    const ai=rankIndex(a);
    const bi=rankIndex(b);
    for(let j=bi; j>ai; j--){ // toward stronger kicker (lower index)
      const kicker=ranks[j];
      res.push(a+kicker+"s");
    }
    return res;
  }

  function expandOffsuitPlus(token){
    // e.g. "ATo+" => ATo, AJo, AQo, AKo
    const a=token[0];
    const b=token[1];
    const ai=rankIndex(a);
    const bi=rankIndex(b);
    const res=[];
    for(let j=bi; j>ai; j--){
      const kicker=ranks[j];
      res.push(a+kicker+"o");
    }
    return res;
  }

  function normalizeToken(tok){
    return tok.replace(/\s+/g, "");
  }

  function applyTokens(map, tokens, action){
    for(let tok of tokens){
      tok = normalizeToken(tok);
      if(!tok) continue;
      if(/^[2-9TJQKA]{2}\+$/.test(tok)){
        // pair+
        expandPairPlus(tok).forEach(h=> map[h]=action);
      } else if(/^[2-9TJQKA]{2}s\+$/.test(tok)){
        expandSuitedPlus(tok).forEach(h=> map[h]=action);
      } else if(/^[2-9TJQKA]{2}o\+$/.test(tok)){
        expandOffsuitPlus(tok).forEach(h=> map[h]=action);
      } else if(/^[2-9TJQKA]{2}$/.test(tok) || /^[2-9TJQKA]{2}[so]$/.test(tok)){
        map[tok]=action;
      } else {
        console.warn("Unrecognized token:", tok);
      }
    }
  }

  function buildRange(def){
    const map={};
    allHands().forEach(h=> map[h]="F");

    // Apply in order: folds default, then calls, mixes, raises, etc (so later rules override)
    if(def.calls) applyTokens(map, def.calls, "C");
    if(def.mixes) applyTokens(map, def.mixes, "M");
    if(def.raises) applyTokens(map, def.raises, "R");

    // Add per-hand notes if provided
    const notes = def.notes || {};
    return { map, notes };
  }

  // --- Scenarios ---
  // You can add more simply by extending this object.
  const scenarios = {
    "BTN_RFI": {
      name: "BTN Open (RFI)",
      kicker: "8-max • rake/ante aware • open ~3x",
      def: {
        raises: [
          "22+",
          "A2s+", "A2o+", // all aces
          "K8s+", "KTo+",
          "Q9s+", "QTo+",
          "J9s+", "JTo",
          "T8s+",
          "97s+",
          "86s+"
        ],
        notes: {
          "AJo":"Prefer 3-bet-or-fold vs earlier opens; as RFI it’s strong enough.",
          "KTo":"Late-position steal; be ready to barrel selectively on good textures.",
          "86s":"Lowest suited connector we open here in this rake environment."
        }
      }
    },

    "CO_RFI": {
      name: "CO Open (RFI)",
      kicker: "8-max • open ~3x",
      def: {
        raises: [
          "22+",
          "A7s+", "ATo+",
          "K9s+", "KJo+",
          "Q9s+", "QJo",
          "J9s+",
          "T9s",
          "98s"
        ],
        notes: {
          "KJo":"Often a fold vs 3-bet OOP; don’t overcall with it.",
          "A7s":"Good wheel/backdoor properties; avoid calling 3-bets OOP too wide."
        }
      }
    },

    "HJ_RFI": {
      name: "HJ Open (RFI)",
      kicker: "8-max • open ~3.5x",
      def: {
        raises: [
          "22+",
          "A9s+", "ATo+",
          "KTs+", "KQo",
          "QTs+",
          "JTs",
          "T9s"
        ]
      }
    },

    "LJ_RFI": {
      name: "LJ / UTG+1 Open (RFI)",
      kicker: "8-max • open ~3.5x",
      def: {
        raises: [
          "22+",
          "ATs+", "AJo+",
          "KQs", "KJs",
          "QJs",
          "JTs"
        ]
      }
    },

    "UTG_RFI": {
      name: "UTG Open (RFI)",
      kicker: "8-max • rake-sensitive • open ~3.5–4x",
      def: {
        raises: [
          "22+",
          "AJs+", "AQo+",
          "KQs"
        ]
      }
    },

    "BB_vs_BTN_3x": {
      name: "BB Defend vs BTN Open (3x)",
      kicker: "Call with playable equity • 3-bet linear/value-heavy",
      def: {
        // For simplicity: mark calls & raises (3-bet) — folds are default.
        raises: [
          "88+",
          "AJs+", "AQo+",
          "KQs",
          "A5s", "A4s",
          "KTs", "QTs", "JTs"
        ],
        calls: [
          "22+",
          "A2s+",
          "K9s+", "Q9s+", "J9s+",
          "T8s+", "97s+", "86s+",
          "KTo+", "QTo+", "JTo"
        ],
        notes: {
          "A2s":"Great as a call; mixes into 3-bet bluffs depending on opener tendencies.",
          "KTo":"Defend vs wide BTN opens; be cautious on K-high boards vs heavy barreling regs."
        }
      }
    }
  };

  // --- UI rendering ---
  const scenarioSel = document.getElementById("scenario");
  const matrixEl = document.getElementById("matrix");
  const scenarioTitle = document.getElementById("scenarioTitle");
  const scenarioKicker = document.getElementById("scenarioKicker");
  const rangePct = document.getElementById("rangePct");
  const cntRaise = document.getElementById("cntRaise");
  const cntCall  = document.getElementById("cntCall");
  const cntMix   = document.getElementById("cntMix");
  const cntFold  = document.getElementById("cntFold");
  const selHand  = document.getElementById("selHand");
  const selAct   = document.getElementById("selAct");
  const selNote  = document.getElementById("selNote");
  const toastEl  = document.getElementById("toast");

  let showLabels = true;

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(()=> toastEl.classList.remove("show"), 1200);
  }

  function handForCell(rowRank, colRank){
    const i = rankIndex(rowRank);
    const j = rankIndex(colRank);
    if(i===j) return rowRank+colRank; // pair
    if(i<j) return rowRank+colRank+"s"; // suited above diagonal
    return rowRank+colRank+"o"; // offsuit below diagonal
  }

  function prettyAction(code){
    return ACT[code]?.label || "—";
  }

  function computeCounts(map){
    const counts={R:0,C:0,M:0,F:0};
    for(const h in map){
      const a=map[h]||"F";
      counts[a] = (counts[a]||0)+1;
    }
    return counts;
  }

  function rangeText(map){
    const groups={R:[],C:[],M:[]};
    Object.entries(map).forEach(([h,a])=>{
      if(a==="R") groups.R.push(h);
      if(a==="C") groups.C.push(h);
      if(a==="M") groups.M.push(h);
    });
    const fmt = arr => arr.sort().join(", ");
    return `Raise: ${fmt(groups.R)}\n\nCall: ${fmt(groups.C)}\n\nMix: ${fmt(groups.M)}`;
  }

  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      toast("Copied range to clipboard");
    }catch(e){
      toast("Copy failed (browser permissions)");
      console.error(e);
    }
  }

  function renderScenario(key){
    const sc = scenarios[key];
    const { map, notes } = buildRange(sc.def);

    scenarioTitle.textContent = sc.name;
    scenarioKicker.textContent = sc.kicker;

    // Build matrix header row
    matrixEl.innerHTML = "";
    matrixEl.appendChild(hdrCorner());
    ranks.forEach(r=> matrixEl.appendChild(hdr(r)));

    // Body
    let selectedFirst = false;
    for(const rRow of ranks){
      matrixEl.appendChild(hdr(rRow));
      for(const rCol of ranks){
        const h = handForCell(rRow, rCol);
        const a = map[h] || "F";
        const el = document.createElement("div");
        el.className = `cell ${ACT[a].cls}`;
        const handLabel = displayHandLabel(rRow, rCol);
        el.innerHTML = `<div class="hand">${handLabel}</div>${showLabels ? `<div class="act">${a}</div>` : ""}`;
        el.addEventListener("click", ()=>{
          selHand.textContent = handLabel;
          selAct.textContent = prettyAction(a);
          const n = notes[h] || defaultNoteFor(a, h, key);
          selNote.textContent = n;
          toast(`${handLabel}: ${prettyAction(a)}`);
        });
        matrixEl.appendChild(el);
        if(!selectedFirst){
          selHand.textContent = "—";
          selAct.textContent = "—";
          selNote.textContent = "Click a cell";
          selectedFirst = true;
        }
      }
    }

    const counts = computeCounts(map);
    cntRaise.textContent = `${counts.R} combos`;
    cntCall.textContent  = `${counts.C} combos`;
    cntMix.textContent   = `${counts.M} combos`;
    cntFold.textContent  = `${counts.F} combos`;

    const playable = counts.R + counts.C + counts.M;
    const pct = (playable / 169 * 100).toFixed(1);
    rangePct.textContent = `${pct}% of hands playable`;

    // Wire copy button
    document.getElementById("copy").onclick = ()=> copyToClipboard(rangeText(map));
  }

  function defaultNoteFor(action, hand, key){
    if(action==="R"){
      if(key.includes("RFI")) return "Open for value + steal equity; rake rewards taking initiative.";
      if(key.includes("BB")) return "3-bet (value/pressure). Prefer linear/value-heavy in this rake environment.";
      return "Raise/3-bet.";
    }
    if(action==="C") return "Call with playable equity; avoid dominated offsuit junk.";
    if(action==="M") return "Mix between call/raise based on opener tendencies and players behind.";
    return "Fold: too dominated / poor equity realization / rake-sensitive.";
  }

  function displayHandLabel(rowRank, colRank){
    const i = rankIndex(rowRank);
    const j = rankIndex(colRank);
    if(i===j) return rowRank+colRank;
    if(i<j) return rowRank+colRank+"s";
    return rowRank+colRank+"o";
  }

  function hdrCorner(){
    const el=document.createElement("div");
    el.className="hdrCell";
    el.textContent="";
    return el;
  }
  function hdr(t){
    const el=document.createElement("div");
    el.className="hdrCell";
    el.textContent=t;
    return el;
  }

  // Populate scenario selector
  const scenarioEntries = Object.entries(scenarios);
  for(const [key, sc] of scenarioEntries){
    const opt=document.createElement("option");
    opt.value=key;
    opt.textContent=sc.name;
    scenarioSel.appendChild(opt);
  }
  scenarioSel.value = scenarioEntries[0][0];
  scenarioSel.addEventListener("change", ()=> renderScenario(scenarioSel.value));

  // Toggle labels
  document.getElementById("toggleLabels").addEventListener("click", (e)=>{
    showLabels = !showLabels;
    e.target.textContent = showLabels ? "Hide action labels" : "Show action labels";
    renderScenario(scenarioSel.value);
  });

  // --- Trainer Mode ---
  const explorerView = document.getElementById("explorerView");
  const trainerView  = document.getElementById("trainerView");
  const modeBtn      = document.getElementById("modeBtn");

  const trainerScenarioSel = document.getElementById("trainerScenario");
  const trainerRandomness  = document.getElementById("trainerRandomness");
  const trainerNextBtn     = document.getElementById("trainerNext");
  const trainerPrompt      = document.getElementById("trainerPrompt");
  const trainerHandEl      = document.getElementById("trainerHand");
  const trainerResult      = document.getElementById("trainerResult");
  const trainerMatrix      = document.getElementById("trainerMatrix");
  const trainerResultTitle = document.getElementById("trainerResultTitle");
  const trainerBadge       = document.getElementById("trainerBadge");
  const trainerExplain     = document.getElementById("trainerExplain");

  const btnRaise = document.getElementById("btnRaise");
  const btnCall  = document.getElementById("btnCall");
  const btnFold  = document.getElementById("btnFold");

  const stCorrect = document.getElementById("stCorrect");
  const stTotal   = document.getElementById("stTotal");
  const stAcc     = document.getElementById("stAcc");
  const stStreak  = document.getElementById("stStreak");
  const stMissed  = document.getElementById("stMissed");

  const trainerReset = document.getElementById("trainerReset");
  const trainerClearHistory = document.getElementById("trainerClearHistory");

  const cache = {}; // scenarioKey -> {map, notes}
  function getScenarioData(key){
    if(!cache[key]){
      cache[key] = buildRange(scenarios[key].def);
    }
    return cache[key];
  }

  // Populate trainer scenario dropdown
  function populateTrainerScenarios(){
    trainerScenarioSel.innerHTML = "";
    // default option: random among all
    const optAll = document.createElement("option");
    optAll.value = "__RANDOM__";
    optAll.textContent = "Random scenario";
    trainerScenarioSel.appendChild(optAll);

    for(const [key, sc] of Object.entries(scenarios)){
      const opt=document.createElement("option");
      opt.value=key;
      opt.textContent=sc.name;
      trainerScenarioSel.appendChild(opt);
    }
    trainerScenarioSel.value = "__RANDOM__";
  }

  // Session stats + missed list stored in localStorage (so it survives refresh)
  const LS_KEY = "preflopTrainer_v1";
  const session = {
    correct: 0,
    total: 0,
    streak: 0,
    missed: [] // array of strings like "BB vs BTN 3x: KTo (correct CALL)"
  };

  function loadSession(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(typeof obj?.correct === "number") session.correct = obj.correct;
      if(typeof obj?.total === "number") session.total = obj.total;
      if(typeof obj?.streak === "number") session.streak = obj.streak;
      if(Array.isArray(obj?.missed)) session.missed = obj.missed;
    } catch(e){ /* ignore */ }
  }

  function saveSession(){
    try{
      localStorage.setItem(LS_KEY, JSON.stringify(session));
    } catch(e){ /* ignore */ }
  }

  function renderStats(){
    stCorrect.textContent = session.correct;
    stTotal.textContent = session.total;
    const acc = session.total ? (session.correct/session.total*100).toFixed(1) : "0.0";
    stAcc.textContent = `${acc}%`;
    stStreak.textContent = session.streak;
    stMissed.textContent = session.missed.length ? session.missed.slice(0, 10).join(" • ") : "—";
  }

  function randomChoice(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function chooseScenarioKey(){
    const v = trainerScenarioSel.value;
    if(v && v !== "__RANDOM__") return v;
    const keys = Object.keys(scenarios);
    return randomChoice(keys);
  }

  function listHands(map, mode){
    const all = Object.keys(map);
    if(mode === "all") return all;
    if(mode === "playable") return all.filter(h => map[h] !== "F");
    if(mode === "edge"){
      // Try to focus on missed hands; if none, fallback to playable
      const missedHands = session.missed
        .map(x => x.split(": ")[1]?.split(" ")[0])
        .filter(Boolean);
      const uniq = [...new Set(missedHands)].filter(h => map[h]);
      return uniq.length ? uniq : all.filter(h => map[h] !== "F");
    }
    return all;
  }

  let current = { scenarioKey: null, hand: null, correct: null, prettyHand: null };

  function setButtonsEnabled(enabled){
    [btnRaise, btnCall, btnFold].forEach(b => b.disabled = !enabled);
  }

  function prettyHandFromCode(code){
    // code like "AKs" or "AJo" or "77"
    return code;
  }

  function scenarioLabel(key){
    return scenarios[key]?.name || key;
  }

  function noteForTrainer(key, handCode, correctAct){
    const { notes } = getScenarioData(key);
    if(notes && notes[handCode]) return notes[handCode];
    // A little more contextual messaging
    if(correctAct === "F") return "Fold: dominated / poor equity realization / rake-sensitive in this spot.";
    if(correctAct === "C") return "Call: defend with playable equity; avoid turning everything into a bloated rake pot.";
    if(correctAct === "R"){
      if(key.includes("RFI")) return "Raise first in: take initiative and capture dead money from antes.";
      return "Raise: value/pressure (linear, rake-aware).";
    }
    if(correctAct === "M") return "Mix: either action can be fine; use opponent tendencies and players behind to choose.";
    return "";
  }

  function renderMiniMatrix(key, selectedHand, selStatus){
    if(!trainerMatrix) return;
    const { map } = getScenarioData(key);

    trainerMatrix.innerHTML = "";
    // header row
    trainerMatrix.appendChild(hdrCorner());
    ranks.forEach(r=> trainerMatrix.appendChild(hdr(r)));

    for(const rRow of ranks){
      trainerMatrix.appendChild(hdr(rRow));
      for(const rCol of ranks){
        const h = handForCell(rRow, rCol);
        const a = map[h] || "F";
        const el = document.createElement("div");
        el.className = `cell ${ACT[a].cls}`;
        el.dataset.hand = h;
        const handLabel = displayHandLabel(rRow, rCol);
        el.innerHTML = `<div class="hand">${handLabel}</div>`;
        if(selectedHand && h === selectedHand){
          el.classList.add("sel");
          if(selStatus === "good") el.classList.add("good");
          if(selStatus === "bad") el.classList.add("bad");
        }
        // allow click to peek in trainer
        el.addEventListener("click", ()=>{
          toast(`${handLabel}: ${prettyAction(a)}`);
        });
        trainerMatrix.appendChild(el);
      }
    }
  }

  function startQuestion(){
    const key = chooseScenarioKey();
    const { map } = getScenarioData(key);
    const mode = trainerRandomness.value;
    const hands = listHands(map, mode);
    const hand = randomChoice(hands);
    const act = map[hand] || "F";

    current = { scenarioKey: key, hand, correct: act, prettyHand: prettyHandFromCode(hand) };

    trainerPrompt.textContent = `${scenarioLabel(key)} — What do you do with:`;
    trainerHandEl.textContent = current.prettyHand;

    trainerResult.style.display = "none";
    trainerBadge.className = "trainerBadge";
    trainerBadge.textContent = "";

    renderMiniMatrix(key, hand, null);
    setButtonsEnabled(true);
  }

  function isCorrect(userAct, correctAct){
    if(correctAct === "M"){
      // Treat MIX as either R or C is acceptable
      return userAct === "R" || userAct === "C";
    }
    return userAct === correctAct;
  }

  function submit(userAct){
    const key = current.scenarioKey;
    const hand = current.hand;
    const correctAct = current.correct;

    session.total += 1;

    const ok = isCorrect(userAct, correctAct);
    if(ok){
      session.correct += 1;
      session.streak += 1;
    } else {
      session.streak = 0;
      const miss = `${scenarioLabel(key)}: ${hand} (correct ${prettyAction(correctAct)})`;
      session.missed.unshift(miss);
      session.missed = session.missed.slice(0, 30);
    }

    saveSession();
    renderStats();

    setButtonsEnabled(false);
    trainerResult.style.display = "block";

    if(ok){
      trainerResultTitle.textContent = "Correct";
      trainerBadge.textContent = "NICE";
      trainerBadge.classList.add("good");
    } else {
      trainerResultTitle.textContent = "Not quite";
      trainerBadge.textContent = `Correct: ${prettyAction(correctAct)}`;
      trainerBadge.classList.add("bad");
    }

    // Explain
    const n = noteForTrainer(key, hand, correctAct);
    if(correctAct === "M"){
      trainerBadge.textContent = "Mix (Raise or Call)";
      trainerBadge.className = "trainerBadge mix";
      trainerExplain.textContent = `${n} (In this trainer, Raise OR Call counts as correct.)`;
    } else {
      trainerExplain.textContent = n;
    }

    // Visual: highlight selected hand as correct/incorrect
    renderMiniMatrix(key, hand, ok ? "good" : "bad");
  }

  function setMode(mode){
    const isTrainer = mode === "trainer";
    explorerView.style.display = isTrainer ? "none" : "grid";
    trainerView.style.display  = isTrainer ? "grid" : "none";
    modeBtn.textContent = isTrainer ? "Back to explorer" : "Trainer mode";

    if(isTrainer){
      startQuestion();
    }
  }

  modeBtn.addEventListener("click", ()=>{
    const isTrainer = trainerView.style.display !== "none";
    setMode(isTrainer ? "explorer" : "trainer");
  });

  trainerNextBtn.addEventListener("click", ()=> startQuestion());
  trainerScenarioSel.addEventListener("change", ()=> startQuestion());
  trainerRandomness.addEventListener("change", ()=> startQuestion());

  btnRaise.addEventListener("click", ()=> submit("R"));
  btnCall.addEventListener("click", ()=> submit("C"));
  btnFold.addEventListener("click", ()=> submit("F"));

  trainerReset.addEventListener("click", ()=>{
    session.correct = 0; session.total = 0; session.streak = 0;
    saveSession();
    renderStats();
    toast("Session reset");
  });

  trainerClearHistory.addEventListener("click", ()=>{
    session.missed = [];
    saveSession();
    renderStats();
    toast("Missed list cleared");
  });

  // Initial render
  renderScenario(scenarioSel.value);
  populateTrainerScenarios();
  loadSession();
  renderStats();

</script>
</body>
</html>
