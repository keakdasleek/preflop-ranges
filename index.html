<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Casey's Poker Tool (Interactive)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#121c3f;
      --text:#e7ecff;
      --muted:#aab3d6;
      --border:#24305f;
      --raise:#24c26a;
      --call:#36a3ff;
      --fold:#ff4d5a;
      --mix:#f6c445;
      --cell:#0c1430;
      --cell2:#0b132b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 30% 10%, #152252 0%, var(--bg) 55%, #070a14 100%);
      color:var(--text);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:22px}
    .hdr{display:flex;gap:14px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap}
    .title{
      display:flex;flex-direction:column;gap:6px
    }
    h1{font-size:20px;margin:0;font-weight:800;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:13px;line-height:1.35}

    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
   /* Buttons */
button{
  background: linear-gradient(180deg, #0b132b, #0f1733);
  color:#e7ecff;
  border:1px solid var(--border);
  border-radius:12px;
  padding:10px 12px;
  font-size:13px;
  outline:none;
  cursor:pointer;
}
  
button:hover{filter:brightness(1.08)}

/* Selects (dark themed with arrow) */
select{
  background: linear-gradient(180deg, #0b132b, #0f1733);
  color:#e7ecff;
  border:1px solid var(--border);
  border-radius:12px;
  padding:10px 32px 10px 12px; /* extra right padding for arrow */
  font-size:13px;
  outline:none;
  appearance:none;
  -webkit-appearance:none;
  -moz-appearance:none;

  /* custom arrow */
  background-image:
    linear-gradient(45deg, transparent 50%, #e7ecff 50%),
    linear-gradient(135deg, #e7ecff 50%, transparent 50%);
  background-position:
    calc(100% - 18px) 55%,
    calc(100% - 13px) 55%;
  background-size:5px 5px;
  background-repeat:no-repeat;
}

select option{
  background-color:#0f1733;
  color:#e7ecff;
}

select:hover{
  filter:brightness(1.08);
}

select:focus{
  border-color:rgba(255,255,255,0.4);
  box-shadow:0 0 0 2px rgba(255,255,255,0.08);
}

    button{cursor:pointer}
    button:hover{filter:brightness(1.08)}

    .gridWrap{margin-top:16px;display:grid;grid-template-columns: 1fr 280px;gap:14px;align-items:start}
    @media (max-width: 900px){
      .gridWrap{grid-template-columns: 1fr;}
    }

    .card{
      background: linear-gradient(180deg, rgba(18,28,63,.88), rgba(12,18,44,.88));
      border:1px solid var(--border);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    .cardHd{padding:14px 14px 10px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap}
    .cardHd .kicker{color:var(--muted);font-size:12px}

    .matrix{
      padding:12px;
      display:grid;
      grid-template-columns: 42px repeat(13, 1fr);
      gap:6px;
    }
    .hdrCell{
      height:32px;
      border-radius:10px;
      display:flex;align-items:center;justify-content:center;
      color:var(--muted);
      font-weight:700;
      font-size:12px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
    }

    .cell{
      position:relative;
      height:44px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(13,20,48,.95), rgba(10,16,38,.95));
      border:1px solid rgba(255,255,255,.07);
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, filter .06s ease;
    }
    .cell:hover{transform: translateY(-1px);filter:brightness(1.06)}

    .cell .hand{font-weight:800;font-size:13px;letter-spacing:.2px}
    .cell .act{
      position:absolute;bottom:6px;right:8px;
      font-size:10px;font-weight:800;opacity:.9
    }

    .act-raise{background: rgba(36,194,106,.14); border-color: rgba(36,194,106,.45)}
    .act-call{background: rgba(54,163,255,.14); border-color: rgba(54,163,255,.45)}
    .act-fold{background: rgba(255,77,90,.10); border-color: rgba(255,77,90,.35)}
    .act-mix{background: rgba(246,196,69,.12); border-color: rgba(246,196,69,.42)}

    /* Mix intensity overlay (set via CSS variables per-cell) */
/* Distribution overlay (Raise/Call/Fold proportions) */
.cell{
  position:relative;
}

/* 3-way stacked bar overlay using CSS variables:
   --r, --c, --f are 0..100 (percent) */
.cell::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  pointer-events:none;

  /* stacked gradient: green then yellow then red */
  background: linear-gradient(
    90deg,
    rgba(36,194,106,0.22) 0% calc(var(--r,0) * 1%),
    rgba(246,196,69,0.18) calc(var(--r,0) * 1%) calc((var(--r,0) + var(--c,0)) * 1%),
    rgba(255,77,90,0.16) calc((var(--r,0) + var(--c,0)) * 1%) 100%
  );
}

/* Optional: show that a cell is truly “mixed” (not 100/0/0) */
.cell.isMixed{
  outline: 1px dashed rgba(246,196,69,0.35);
  outline-offset: -2px;
}

.boardSlots{
  display:flex;
  gap:10px;
}

.boardSlot{
  width:44px;
  height:56px;
  border-radius:10px;
  background:rgba(255,255,255,0.05);
  border:1px dashed rgba(255,255,255,0.25);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  font-size:18px;
  cursor:pointer;
}

.boardSlot.red{ color:#ff6b6b; }
.boardSlot.black{ color:#ddd; }

.boardSlot.active{
  outline:2px solid #5da9ff;
}



/* Optional tiny mix % badge in the cell */
.cell .mixPct{
  position:absolute;
  bottom:6px;
  left:8px;
  font-size:10px;
  font-weight:900;
  opacity:.9;
  color: rgba(231,236,255,.9);
}
@media (max-width: 520px){
  .cell .mixPct{ display:none; } /* keep mobile clean */
}


    .side{padding:14px}
    .legend{display:grid;gap:10px;margin-top:6px}
    .pill{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 12px;border-radius:14px;border:1px solid var(--border);background: rgba(255,255,255,.03)}
    .dot{width:12px;height:12px;border-radius:99px}
    .dot.raise{background:var(--raise)}
    .dot.call{background:var(--call)}
    .dot.fold{background:var(--fold)}
    .dot.mix{background:var(--mix)}
    .pill b{font-size:13px}
    .pill span{color:var(--muted);font-size:12px}

    .info{margin-top:14px;padding:12px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background: rgba(255,255,255,.03)}
    .info h3{margin:0 0 8px;font-size:13px}
    .kv{display:grid;grid-template-columns: 1fr 1fr;gap:8px}
    .kv div{padding:8px;border-radius:12px;background: rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)}
    .kv .k{color:var(--muted);font-size:11px}
    .kv .v{font-weight:800;font-size:13px;margin-top:2px}

    .footerNote{margin-top:14px;color:var(--muted);font-size:12px;line-height:1.4}

      /* Postflop input */
    .pfInput{
      flex:1;
      min-width:180px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      color: var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-size:13px;
      font-weight:800;
      outline:none;
    }

    /* Compact board input so the whole row stays on one line */
.pfInput.compact{
  flex: 0 0 170px;     /* fixed-ish width */
  max-width: 170px;
  min-width: 170px;
  padding: 8px 10px;
  font-size: 12px;
}

/* ===== Board sidebar: forced two-row layout ===== */

.boardRow{
  display:flex;
  flex-direction:column;
  gap:10px;
}

/* Row 1: chips (always one horizontal row) + optional tiny input */
.boardTopRow{
  display:flex;
  align-items:center;
  gap:10px;
  width:100%;
  min-width:0;
}

/* Hard rule: never wrap the 3 flop chips */
.boardChips{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;         /* KEY: prevents vertical stacking */
  min-width:0;
  overflow:hidden;          /* avoid pushing layout */
}

/* If chips get tight, allow horizontal scroll instead of wrapping */
.boardChips{
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
}
.boardChips::-webkit-scrollbar{height:10px}
.boardChips::-webkit-scrollbar-thumb{background: rgba(255,255,255,.10); border-radius:999px}

/* Make each chip a fixed-ish width so they stay consistent */
.pfChip{
  flex: 0 0 auto;           /* KEY: chip never shrinks into wrap */
}

/* Tiny input (optional) */
.pfInput.tiny{
  flex: 0 0 auto;
  width: 96px;
  max-width: 96px;
  min-width: 96px;
  padding: 8px 10px;
  font-size: 12px;
  font-weight: 800;
}

/* Row 2: Pick board + Apply */
.boardBottomRow{
  display:flex;
  align-items:center;
  gap:10px;
  width:100%;
}

/* Mobile: allow Row 2 buttons to wrap, and make input full width if present */
@media (max-width: 520px){
  .boardTopRow{
    flex-wrap:wrap;
  }
  .pfInput.tiny{
    width:100%;
    max-width:none;
    min-width:0;
  }
  .boardBottomRow{
    flex-wrap:wrap;
  }
}

/* Selected flop chips inside the modal */
#boardModalChips{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}

.pfChip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  font-weight:900;
  cursor:pointer;
  min-width:68px;
}

.pfChip.active{
  outline:2px solid rgba(93,169,255,.95);
  outline-offset:-2px;
}

/* Highlight cards that are currently selected (even beyond "disabled") */
.pfCardBtn.selected{
  outline: 2px solid rgba(93,169,255,.95);
  outline-offset:-2px;
  background: rgba(93,169,255,.10);
}



    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background: rgba(15,23,51,.95);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      box-shadow:0 14px 30px rgba(0,0,0,.35);
      opacity:0;pointer-events:none;
      transition: opacity .15s ease, transform .15s ease;
      font-size:13px;
      max-width:min(560px, calc(100vw - 22px));
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-3px)}

    .tag{
      padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size:11px;font-weight:800;
    }

    /* Board modal primary action when flop is complete */
.pfPrimary{
  background: rgba(36,194,106,.18);
  border-color: rgba(36,194,106,.55);
  font-weight: 950;
}
.pfPrimary:hover{ filter:brightness(1.10); }
.pfPrimary:disabled{
  opacity:.45;
  cursor:not-allowed;
  filter:none;
}


    /* Trainer */
    .trainerPrompt{padding:12px 14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background: rgba(255,255,255,.03);font-weight:800;line-height:1.35}
    .trainerHandRow{display:flex;gap:14px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .trainerHand{font-size:34px;font-weight:950;letter-spacing:.6px;padding:12px 16px;border-radius:18px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.18);min-width:150px;text-align:center}
    .trainerBtns{display:flex;gap:10px;flex-wrap:wrap}
    .btnAct{padding:12px 14px;border-radius:14px;border:1px solid rgba(255,255,255,.10);font-weight:900;min-width:110px}
    .btnAct.raise{background: rgba(36,194,106,.14);border-color: rgba(36,194,106,.45)}
    .btnAct.call{background: rgba(54,163,255,.14);border-color: rgba(54,163,255,.45)}
    .btnAct.fold{background: rgba(255,77,90,.10);border-color: rgba(255,77,90,.35)}
    .btnAct:disabled{opacity:.55;cursor:not-allowed;filter:none}
    .trainerResult{padding:12px 14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background: rgba(255,255,255,.03)}
    .trainerResultTop{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
    .trainerBadge{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);font-size:11px;font-weight:950;letter-spacing:.4px}
    .trainerBadge.good{background: rgba(36,194,106,.14);border-color: rgba(36,194,106,.45)}
    .trainerBadge.bad{background: rgba(255,77,90,.12);border-color: rgba(255,77,90,.35)}
    .trainerBadge.mix{background: rgba(246,196,69,.12);border-color: rgba(246,196,69,.42)}
    .trainerExplain{margin-top:8px;color:var(--muted);font-size:12px;line-height:1.45;font-weight:700}
    #trainerPersonaLine{
  margin-top:6px;
  font-style: italic;
  opacity:.9;
}



    .matrixScroll{overflow-x:auto; -webkit-overflow-scrolling:touch; padding-bottom:6px}
    .matrixScroll::-webkit-scrollbar{height:10px}
    .matrixScroll::-webkit-scrollbar-thumb{background: rgba(255,255,255,.10); border-radius:999px}

    /* Mobile sizing tweaks */
    @media (max-width: 520px){
      .wrap{padding:14px}
      .controls{width:100%}
      select, button{width:100%}
      .matrix{grid-template-columns: 34px repeat(13, minmax(26px, 1fr)); gap:5px; padding:10px}
      .cell{height:34px; border-radius:10px}
      .cell .hand{font-size:11px}
      .cell .act{display:none}
      .hdrCell{height:26px; border-radius:9px; font-size:11px}
      .trainerHand{font-size:28px; min-width:130px}
      .btnAct{min-width:96px; width:100%}
      .trainerBtns{width:100%}
      .trainerHandRow{gap:10px}
    }

    /* Trainer mini grid */
    .miniWrap{border:1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.02); border-radius:16px; padding:10px}
    .miniTitle{color:var(--muted); font-size:12px; font-weight:900; margin:2px 0 8px}
    .matrix.mini{grid-template-columns: 34px repeat(13, minmax(22px, 1fr)); gap:4px; padding:8px}
    .matrix.mini .cell{height:28px; border-radius:9px}
    .matrix.mini .cell .hand{font-size:10px}
    .matrix.mini .hdrCell{height:22px; border-radius:8px; font-size:10px}
    .cell.sel{outline: 3px solid rgba(255,255,255,.85); outline-offset: -2px}
    .cell.sel.good{outline-color: rgba(36,194,106,.95)}
    .cell.sel.bad{outline-color: rgba(255,77,90,.95)}

/* ===== Hand Logger: Table UI ===== */
.loggerTableWrap{
  display:grid;
  gap:12px;
}

.loggerTableControls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}

.trainerTopControls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
}


.loggerModePill{
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  font-size:11px;
  font-weight:950;
  letter-spacing:.3px;
  color: var(--muted);
}

.loggerModePill.on{
  color: var(--text);
  border-color: rgba(93,169,255,.55);
  background: rgba(93,169,255,.10);
}

.loggerTable{
  position:relative;
  width:min(520px, 100%);
  aspect-ratio: 1 / 1;
  margin:0 auto;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background: radial-gradient(60% 60% at 50% 35%, rgba(255,255,255,.05), rgba(0,0,0,.22));
  box-shadow: 0 14px 30px rgba(0,0,0,.30);
  overflow:hidden;
}

.loggerTable::before{
  content:"";
  position:absolute;
  inset:12%;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.12);
}

.loggerSeat{
  position:absolute;
  width:72px;
  height:46px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  display:flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  font-weight:950;
  cursor:pointer;
  user-select:none;
  transform: translate(-50%, -50%);
}

.loggerSeat:hover{ filter:brightness(1.08); }

.loggerSeat .lbl{
  font-size:12px;
  color: var(--muted);
  font-weight:900;
}

.loggerSeat .tag{
  padding:3px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  font-size:10px;
  font-weight:950;
  color: var(--text);
}

.loggerSeat.hero{
  border-color: rgba(36,194,106,.55);
  background: rgba(36,194,106,.12);
}

.loggerSeat.btn{
  border-color: rgba(246,196,69,.55);
  background: rgba(246,196,69,.10);
}

.loggerSeat.hero .tag{ border-color: rgba(36,194,106,.55); background: rgba(36,194,106,.14); }
.loggerSeat.btn  .tag{ border-color: rgba(246,196,69,.55); background: rgba(246,196,69,.14); }

.loggerTableLegend{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
  color: var(--muted);
  font-size:12px;
  font-weight:800;
}

.loggerLegendDot{
  width:10px;
  height:10px;
  border-radius:999px;
  display:inline-block;
}

.loggerLegendDot.hero{ background: var(--raise); } /* using your green */
.loggerLegendDot.btn{ background: var(--mix); }    /* using your yellow */
/* ===== /Hand Logger: Table UI ===== */

/* ===== Hand Logger: Hands sidebar rows should never wrap ===== */
#loggerHandsList .loggerHandRow,
#loggerHandsList .loggerHandItem,
#loggerHandsList button{
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* If your rows are flex containers (recommended) */
#loggerHandsList .loggerHandRow{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

#loggerHandsList .loggerHandRow .left{
  min-width: 0;          /* critical for ellipsis inside flex */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#loggerHandsList .loggerHandRow .right{
  flex: 0 0 auto;
  white-space: nowrap;
  opacity: 0.95;
}


    
    /* Modal */
    .modal{position:fixed;inset:0;z-index:50}
    .modalBackdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
    .modalPanel{position:relative;max-width:820px;margin:18px auto;background: linear-gradient(180deg, rgba(18,28,63,.98), rgba(12,18,44,.98));border:1px solid var(--border);border-radius:18px;box-shadow:0 18px 50px rgba(0,0,0,.55);overflow:hidden}
    .modalHd{padding:12px 12px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:10px}
    .modalBody{padding:14px;max-height:70vh;overflow:auto}
    .gloss{display:grid;gap:10px}
    .gRow{display:grid;grid-template-columns:110px 1fr;gap:10px;padding:10px;border-radius:14px;background: rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08)}
    .gKey{font-weight:950;color:var(--text)}
    .gVal{color:var(--muted);font-size:13px;line-height:1.45;font-weight:700}
    @media (max-width: 520px){
      .modalPanel{margin:10px;}
      .gRow{grid-template-columns:90px 1fr}
      .gVal{font-size:12px}
    }

   /* Postflop board picker UI */
.pfChip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:6px;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  font-weight:900;
  cursor:pointer;
  min-width:68px;
}
.pfChip.active{
  outline:2px solid rgba(255,255,255,.85);
  outline-offset:-2px;
}
.pfChip .muted{ color:var(--muted); font-weight:800; font-size:11px; }

.pfCardGrid{
  display:grid;
  gap:10px;
}
.pfSuitRow{
  display:grid;
  grid-template-columns: 38px repeat(13, 1fr);
  gap:6px;
  align-items:center;
}
.pfSuitLabel{
  text-align:center;
  font-weight:950;
  color:var(--muted);
  border:1px solid rgba(255,255,255,.08);
  background: rgba(255,255,255,.03);
  border-radius:10px;
  padding:8px 0;
}
.pfCardBtn{
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.03);
  padding:8px 0;
  font-weight:950;
  cursor:pointer;
  text-align:center;
  user-select:none;
}
.pfCardBtn:hover{ filter:brightness(1.08); }
.pfCardBtn.disabled{
  opacity:.35;
  cursor:not-allowed;
  filter:none;
}
.pfRed{ color:#ff7b86; }
.pfBlack{ color:#e7ecff; }

    
    /* ===== Postflop Board Picker ===== */
    .pfCardRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 14px}
    .pfCard{
      width:72px; height:96px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }
    .pfCard.active{outline: 3px solid rgba(255,255,255,.85); outline-offset:-2px}
    .pfCard .pfRank{font-size:24px; font-weight:950; letter-spacing:.4px}
    .pfCard .pfSuit{
      position:absolute;
      right:10px; bottom:10px;
      font-size:20px;
      opacity:.95;
    }
    .pfSuitRed{color: rgba(255,77,90,.95)}
    .pfSuitBlk{color: rgba(231,236,255,.95)}
    .pfPickerGrid{display:grid; gap:12px}
    .pfPickerSection{padding:10px; border-radius:14px; border:1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.03)}
    .pfPickerTitle{font-size:12px; color:var(--muted); font-weight:950; letter-spacing:.3px; margin-bottom:8px}
    .pfBtnGrid{display:flex; flex-wrap:wrap; gap:8px}
    .pfBtn{
      min-width:40px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color:var(--text);
      font-weight:900;
      cursor:pointer;
    }
    .pfBtn:hover{filter:brightness(1.08)}
    .pfBtn.sel{outline:2px solid rgba(255,255,255,.8); outline-offset:-2px}
    .pfBtn.suit{min-width:48px; font-size:18px; padding:6px 10px}
    .pfPickerActions{display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:10px}
    /* ===== /Postflop Board Picker ===== */


    
</style>
</head>
<body>
  <div class="wrap">
    <div class="hdr">
      <div class="title">
        <h1>Casey's Poker Tool (Interactive)</h1>
        <div class="sub">
          Built for <span class="tag">8-max</span> <span class="tag">$0.05/$0.10</span> <span class="tag">$0.05 ante</span> <span class="tag">4% rake (cap fast)</span> and typical <span class="tag">3–4x</span> opens.
          <br/>Tip: click any hand to see the action and why it’s there.
        </div>
      </div>
<div class="controls">
  <select id="scenario"></select>
  <select id="persona" title="Opponent persona">
  <option value="Standard">Standard</option>
  <option value="Tight">Tight</option>
  <option value="Loose">Loose</option>
  <option value="Aggro 3bettor">Aggro 3bettor</option>
  <option value="Limper">Limper</option>
</select>


        <button id="toggleLabels">Hide action labels</button>
        <button id="copy">Copy current range as text</button>
        <button id="modeBtn">Trainer mode</button>
        <button id="loggerBtn">Hand logger</button>
        <button id="helpBtn" title="Help / definitions">Help</button>
      </div>
    </div>

    <div id="explorerView" class="gridWrap">
      <div class="card">
        <div class="cardHd">
          <div>
            <div style="font-weight:900" id="scenarioTitle">—</div>
            <div class="kicker" id="scenarioKicker">—</div>
          </div>
          <div class="kicker" id="mixNote">Green = Raise/Open/3B • Blue = Call • Red = Fold • Yellow = Mix</div>
        </div>
        <div class="matrixScroll"><div class="matrix" id="matrix"></div></div>
      </div>

      <div class="card side">
<div class="boardRow">
  <div id="boardSlots" class="boardSlots"></div>
  <div id="boardSummary" class="kicker" style="margin-top:8px">Flop: —</div>

<div class="boardControls">
  <button id="boardPick">Pick board</button>
  <button id="boardApply">Apply</button>
</div>

<div class="info" style="margin-top:10px">
  <h3>Postflop baseline</h3>
  <div id="postflopLine" class="kicker" style="color:var(--muted); font-size:12px; line-height:1.45; font-weight:700;">
    Pick a flop and click <b>Apply</b> to see a baseline plan.
  </div>
</div>

</div>





        <div class="legend">
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot raise"></div><b>Raise</b></div><span id="cntRaise">—</span></div>
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot call"></div><b>Call</b></div><span id="cntCall">—</span></div>
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot mix"></div><b>Mix</b></div><span id="cntMix">—</span></div>
          <div class="pill"><div style="display:flex;align-items:center;gap:10px"><div class="dot fold"></div><b>Fold</b></div><span id="cntFold">—</span></div>
        </div>

<div class="info">
  <h3>Selected Hand</h3>
  <div class="kv">
    <div>
      <div class="k">Hand</div>
      <div class="v" id="selHand">—</div>
    </div>

<div style="grid-column:1 / -1">
  <div class="k">Hand awareness (vs flop)</div>
  <div class="v" id="selHandAwareness" style="font-size:12px;font-weight:800;color:var(--muted);line-height:1.35">
    Pick a flop and click Apply.
  </div>
</div>

    
    <div>
      <div class="k">Action</div>
      <div class="v" id="selAct">—</div>
    </div>

    <div style="grid-column:1 / -1">
      <div class="k">Note</div>
      <div class="v" id="selNote" style="font-size:12px;font-weight:700;color:var(--muted);line-height:1.35">
        Click a cell
      </div>
    </div>

    <!-- New block -->
    <div style="grid-column:1 / -1">
      <div class="k">Standard vs Persona</div>
      <div class="v" id="selDelta" style="font-size:12px;font-weight:800;color:var(--muted);line-height:1.35">
        —
      </div>
    </div>
  </div>
</div>





       
        <div class="footerNote">
          These are practical, rake-aware ranges (not solver-perfect). We can add more scenarios (ISO vs limps, 4-bets, squeeze, BB vs 4x, etc.) once you like the look/feel.
        </div>
      </div>
    </div>
  </div>


  <!-- TRAINER_VIEW_START -->

    <!-- Trainer View -->
       <!-- Trainer View -->
    <div id="trainerView" class="gridWrap" style="display:none">
      <div class="card">
        <div class="cardHd">
          <div>
            <div style="font-weight:900">Trainer Mode</div>
            <div class="kicker" id="trainerKicker">Random spot + random hand. Choose the action you’d take.</div>
          </div>
<div class="trainerTopControls">
  <select id="trainerScenario" title="Scenario"></select>
  <select id="trainerRandomness" title="Hand selection">
    <option value="smart">Smart practice (recommended)</option>
    <option value="all">All hands (uniform)</option>
    <option value="playable">Playable hands only (R/C/M)</option>
    <option value="edge">Focus mistakes (missed hands)</option>
  </select>
  <button id="trainerNext" class="pfPrimary">Next</button>
</div>

        </div>

        <div style="padding:16px;display:grid;gap:14px">
          <div class="trainerPrompt" id="trainerPrompt">—</div>

          <div class="miniWrap" id="trainerRef" style="display:none">
            <div class="miniTitle">Reference grid (current scenario)</div>
            <div class="matrixScroll"><div class="matrix mini" id="trainerMatrix"></div></div>
          </div>

          <div class="trainerHandRow">
            <div class="trainerHand" id="trainerHand">—</div>
            <div class="trainerBtns">
              <button class="btnAct raise" id="btnRaise">Raise</button>
              <button class="btnAct call" id="btnCall">Call</button>
              <button class="btnAct fold" id="btnFold">Fold</button>
            </div>
          </div>

          <div class="trainerResult" id="trainerResult" style="display:none">
            <div class="trainerResultTop">
              <div>
                <div class="kicker">Result</div>
                <div style="font-weight:900;font-size:16px" id="trainerResultTitle">—</div>
              </div>
              <div class="trainerBadge" id="trainerBadge">—</div>
            </div>

           <div class="trainerExplain" id="trainerChoiceLine" style="margin-top:8px">—</div>
<div class="trainerExplain" id="trainerPersonaLine">—</div>
<div class="trainerExplain" id="trainerExplain">—</div>

          </div>
        </div>
      </div>

      <div class="card side">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <div style="font-weight:900">Stats</div>
          <div class="kicker" id="trainerSession">This session</div>
        </div>

        <div class="info" style="margin-top:10px">
          <div class="kv">
            <div><div class="k">Correct</div><div class="v" id="stCorrect">0</div></div>
            <div><div class="k">Total</div><div class="v" id="stTotal">0</div></div>
            <div><div class="k">Accuracy</div><div class="v" id="stAcc">0%</div></div>
            <div><div class="k">Streak</div><div class="v" id="stStreak">0</div></div>
            <div style="grid-column:1 / -1">
              <div class="k">Missed hands (recent)</div>
              <div class="v" id="stMissed" style="font-size:12px;font-weight:700;color:var(--muted);line-height:1.35">—</div>
            </div>
          </div>
        </div>

        <div class="footerNote">
          Tip: Start with “Playable hands only” to build intuition, then switch to “All hands” to eliminate leaks.
          <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap">
            <button id="trainerReset">Reset session</button>
            <button id="trainerClearHistory">Clear missed list</button>
          </div>
        </div>
      </div>
    </div>

<!-- TRAINER_VIEW_END -->
  
    </div>

<!-- LOGGER_VIEW_START -->
<div id="loggerView" class="gridWrap" style="display:none">
  <div class="card">
    <div class="cardHd">
      <div>
        <div style="font-weight:900">Hand Logger</div>
        <div class="kicker">Create sessions, then log hands street-by-street.</div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
        <button id="loggerNewSession">New session</button>
        <select id="loggerSessionSel"></select>
        <button id="loggerNewHand">Log new hand</button>
      </div>
    </div>

    <div style="padding:16px;display:grid;gap:14px">
     <div class="info">
  <h3>Session</h3>
  <div id="loggerSessionSummary" class="kicker">
    No session selected.
  </div>

  <div id="loggerSessionSettings" style="margin-top:10px"></div>
</div>


      <div class="info" style="margin:0">
        <h3>Table</h3>
        <div id="loggerTableMount" class="kicker" style="color:var(--muted)">
          (Table UI goes here — player always at 6 o’clock.)
        </div>
      </div>

      <div class="info" style="margin:0">
        <h3>Hand</h3>
        <div id="loggerHandEditor" class="kicker" style="color:var(--muted)">
          Select a session and click “Log new hand”.
        </div>
      </div>
    </div>
  </div>

  <div class="card side">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
      <div style="font-weight:900">Hands</div>
      <div class="kicker">This session</div>
    </div>

    <div class="info" style="margin-top:10px">
      <div id="loggerHandsList" class="kicker" style="color:var(--muted);font-size:12px;line-height:1.45;font-weight:700">
        —
      </div>
    </div>

    <div class="footerNote">
      v1 goal: fast logging flow (positions auto-populate from hero seat).
    </div>
  </div>
</div>
<!-- LOGGER_VIEW_END -->

  
  <div class="toast" id="toast"></div>

  <!-- Logger Card Picker Modal -->
<div id="loggerCardModal" class="modal" style="display:none">
  <div class="modalBackdrop" id="loggerCardBackdrop"></div>
  <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="loggerCardTitle">
    <div class="modalHd">
      <div>
        <div id="loggerCardTitle" style="font-weight:950">Pick cards</div>
        <div class="kicker" id="loggerCardSub">Select cards for this hand.</div>
      </div>
      <button id="loggerCardClose">Close</button>
    </div>

    <div class="modalBody">
      <div class="kicker" style="margin-bottom:10px">
        Click a slot, then click a card. Click the slot again to clear it.
      </div>

      <div id="loggerCardSlots" class="pfCardRow"></div>

      <div class="info" style="margin-top:10px">
        <h3 style="margin:0 0 8px">Deck</h3>
        <div id="loggerCardGrid" class="pfCardGrid"></div>
      </div>

      <div class="pfPickerActions">
        <button id="loggerCardClearAll">Clear all</button>
        <button id="loggerCardSave" class="pfPrimary">Save</button>
      </div>
    </div>
  </div>
</div>

  
  <!-- Help Modal (mobile-friendly) -->
  <div id="helpModal" class="modal" style="display:none">
    <div class="modalBackdrop" id="helpBackdrop"></div>
    <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <div class="modalHd">
        <div>
          <div id="helpTitle" style="font-weight:950">Help & Definitions</div>
          <div class="kicker">Quick glossary for the charts and trainer.</div>
        </div>
        <button id="helpClose">Close</button>
      </div>
<div class="modalBody">

  <!-- Quick Start Onboarding -->
  <div class="gloss" style="margin-bottom:14px">

    <div class="gRow">
      <div class="gKey">What is this?</div>
      <div class="gVal">
        This is an interactive training and exploration tool for learning practical, rake-aware poker strategy.
        It helps you understand which hands to play, why they’re played, and how table dynamics change decisions.
      </div>
    </div>

    <div class="gRow">
      <div class="gKey">How to start</div>
      <div class="gVal">
        <ol style="margin:0; padding-left:18px">
          <li>Select a scenario (top left).</li>
          <li>(Optional) Choose a persona to model opponent tendencies.</li>
          <li>Click hands in the grid to see recommended actions and explanations.</li>
          <li>Switch to Trainer mode to test your instincts.</li>
        </ol>
      </div>
    </div>

    <div class="gRow">
      <div class="gKey">Explorer mode</div>
      <div class="gVal">
        Lets you inspect full ranges. Click any hand to see its action, reasoning, and how personas change it.
      </div>
    </div>

    <div class="gRow">
      <div class="gKey">Trainer mode</div>
      <div class="gVal">
        Shows you a random spot and hand. Choose Raise, Call, or Fold and get instant feedback.
      </div>
    </div>

    <div class="gRow">
      <div class="gKey">Personas</div>
      <div class="gVal">
        Personas represent different opponent pools (tight, loose, aggressive, passive) and shift frequencies accordingly.
      </div>
    </div>

    <div class="gRow">
      <div class="gKey">Postflop baseline</div>
      <div class="gVal">
        Pick a flop to see a high-level continuation betting plan based on board texture and opponent type.
        This is guidance, not solver output.
      </div>
    </div>

  </div>

  <div class="gloss">

          <div class="gRow"><div class="gKey">RFI</div><div class="gVal"><b>Raise First In</b> — you are the first player to open the pot (no one has raised before you).</div></div>
          <div class="gRow"><div class="gKey">UTG</div><div class="gVal"><b>Under the Gun</b> — first position to act preflop (8-max).</div></div>
          <div class="gRow"><div class="gKey">UTG+1</div><div class="gVal">The next seat after UTG. In this app it’s grouped as <b>LJ / UTG+1</b> for 8-max.</div></div>
          <div class="gRow"><div class="gKey">LJ / HJ / CO / BTN</div><div class="gVal"><b>LoJack</b>, <b>HiJack</b>, <b>Cutoff</b>, <b>Button</b> — progressively later positions with more stealing power.</div></div>
          <div class="gRow"><div class="gKey">SB / BB</div><div class="gVal"><b>Small Blind</b> / <b>Big Blind</b> — the two forced blind positions.</div></div>
          <div class="gRow"><div class="gKey">3x / 4x</div><div class="gVal">Open size in big blinds (e.g., 3x = raise to 3×BB).</div></div>
          <div class="gRow"><div class="gKey">Mix</div><div class="gVal">Either action can be fine. In Trainer Mode, <b>Raise or Call</b> counts as correct when the chart says MIX.</div></div>
          <div class="gRow"><div class="gKey">Why so tight early?</div><div class="gVal">This game has big antes and a rake cap that hits fast. Marginal, dominated hands (especially offsuit) lose money without initiative.</div></div>
        </div>
        <div class="kicker" style="margin-top:12px">Tip: On mobile, open this Help from the top bar whenever a label isn’t intuitive.</div>
        <div class="gRow"><div class="gKey">Persona</div><div class="gVal"><b>Opponent profile</b> — Personas shift the baseline strategy to reflect different table dynamics and tendencies.</div></div>
<div class="gRow"><div class="gKey">Standard</div><div class="gVal">Baseline, “solid regs + normal pool.” Balanced, rake-aware ranges.</div></div>
<div class="gRow"><div class="gKey">Tight</div><div class="gVal">Opponents defend less and apply less pressure. You can value-bet more, but don’t overbluff. Some marginal opens/defends tighten up.</div></div>
<div class="gRow"><div class="gKey">Loose</div><div class="gVal">Opponents continue too wide and make more postflop mistakes. You can defend a bit wider and prioritize hands with good equity realization.</div></div>
<div class="gRow"><div class="gKey">Aggro 3bettor</div><div class="gVal">Players 3-bet more and apply pressure. You tighten marginal opens, and some playable continues shift toward raise/3-bet to avoid getting squeezed.</div></div>
<div class="gRow"><div class="gKey">Limper</div><div class="gVal">Passive pool tendency (calls more, raises less). Opens get called more often. Prefer hands that realize equity well; less need for bluff-3-betting.</div></div>

      </div>
    </div>
  </div>

<!-- Board Picker Modal -->
<div id="boardModal" class="modal" style="display:none">
  <div class="modalBackdrop" id="boardBackdrop"></div>
  <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="boardTitle">
    <div class="modalHd">
      <div>
        <div id="boardTitle" style="font-weight:950">Pick a flop</div>
        <div class="kicker">Click cards to fill Flop 1 → Flop 2 → Flop 3 (auto-advances).</div>
      </div>
      <button id="boardClose">Close</button>
    </div>
    <div class="modalBody">
      <div class="info" style="margin:0 0 12px 0">
        <div class="k" style="color:var(--muted); font-size:11px; font-weight:900; margin-bottom:8px;">Selected flop</div>
        <div id="boardModalChips" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <button id="boardClear">Clear</button>
          <button id="boardUse">Use this flop</button>
        </div>
      </div>

      <div id="boardCardGrid" class="pfCardGrid"></div>
    </div>
  </div>
</div>

  
<script>
  const ranks = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];

  // Action codes
  const ACT = {
    R: {label:"RAISE", cls:"act-raise", color:"var(--raise)"},
    C: {label:"CALL",  cls:"act-call",  color:"var(--call)"},
    F: {label:"FOLD",  cls:"act-fold",  color:"var(--fold)"},
    M: {label:"MIX",   cls:"act-mix",   color:"var(--mix)"},
  };

// ===== Distribution helpers (single canonical block) =====
// Dist is always an object: {R:0..1, C:0..1, F:0..1}

function normalizeDist(d){
  const out = { R:0, C:0, F:0 };
  if(!d) return out;
  out.R = Number(d.R || 0);
  out.C = Number(d.C || 0);
  out.F = Number(d.F || 0);
  const s = out.R + out.C + out.F;
  if(s <= 0) return out;
  out.R /= s; out.C /= s; out.F /= s;
  return out;
}

function dist(action, p=1){
  const d = { R:0, C:0, F:0 };
  if(action === "R" || action === "C" || action === "F") d[action] = p;
  return normalizeDist(d);
}

function isMix(d){
  d = normalizeDist(d);
  const eps = 1e-9;
  let n = 0;
  if(d.R > eps) n++;
  if(d.C > eps) n++;
  if(d.F > eps) n++;
  return n >= 2;
}

function primaryAction(d){
  d = normalizeDist(d);
  let best = "F";
  let bestV = d.F;
  if(d.R > bestV){ best="R"; bestV=d.R; }
  if(d.C > bestV){ best="C"; bestV=d.C; }
  return best;
}

// Convert a dist to a single code used by the UI/trainer: R/C/F/M
function distToCode(d){
  d = normalizeDist(d);
  if(isMix(d)) return "M";
  return primaryAction(d);
}

function distPretty(d){
  d = normalizeDist(d);
  const parts = [];
  if(d.R > 0) parts.push(`Raise ${(d.R*100).toFixed(0)}%`);
  if(d.C > 0) parts.push(`Call ${(d.C*100).toFixed(0)}%`);
  if(d.F > 0) parts.push(`Fold ${(d.F*100).toFixed(0)}%`);
  return parts.join(" / ");
}

function codeLabelFromDist(d){
  const dd = normalizeDist(d);
  const code = distToCode(dd);
  if(code !== "M") return prettyAction(code);
  return `MIX (${distPretty(dd)})`;
}

function formatDistShort(d){
  d = normalizeDist(d);
  if(isMix(d)){
    const r = Math.round(d.R*100);
    const c = Math.round(d.C*100);
    const f = Math.round(d.F*100);
    // Only show non-zero components to keep it clean
    const parts = [];
    if(r) parts.push(`R${r}`);
    if(c) parts.push(`C${c}`);
    if(f) parts.push(`F${f}`);
    return `Mix (${parts.join("/")})`;
  }
  return prettyAction(distToCode(d)); // R/C/F label
}

function buildTrainerPersonaDeltaText(hand, scenarioKey){
  const personaName = personaSel?.value || "Standard";
  const { baseDist, personaDist } = getBaseAndPersonaDistsForHand(hand, scenarioKey);

  const stdShort = formatDistShort(baseDist);
  const pShort   = formatDistShort(personaDist);

  // Always show scenario + persona; show delta only if meaningful
  if(stdShort === pShort){
    return `Persona: ${personaName} • (Same as Standard for this hand)`;
  }

  return `Persona: ${personaName} • Standard: ${stdShort} → ${personaName}: ${pShort}`;
}

  
function getBaseAndPersonaDistsForHand(hand, scenarioKey){
  // BASE (Standard)
  const baseBuilt = buildRange(applyPersona(scenarios[scenarioKey].def, scenarioKey, "Standard"));
  const baseMap = baseBuilt.map;
  const baseMix = baseBuilt.mixWeights || {};
  const baseDist = actionToDist(hand, baseMap[hand], baseMix);

  // PERSONA (current selection)
  const personaLabel = personaSel?.value || "Standard";
  const personaCode = PERSONA_CODE[personaLabel] || "STD";

  // start from same token-adjusted def (so Tight/Loose token edits still apply)
  const defAdj = applyPersona(scenarios[scenarioKey].def, scenarioKey, personaLabel);
  const built = buildRange(defAdj);
  const personaBuilt = applyPersonaToBuiltRange(built, scenarioKey, personaCode);

  const pDist = actionToDist(hand, personaBuilt.map[hand], personaBuilt.mixWeights || {});
  return { baseDist: normalizeDist(baseDist), personaDist: normalizeDist(pDist) };
}

function explainDelta(hand, scenarioKey, baseDist, personaDist){
  const baseCode = distToCode(baseDist);
  const pCode = distToCode(personaDist);
  if(baseCode === pCode && baseCode !== "M") return "No change: persona doesn’t meaningfully shift this hand here.";
  if(baseCode === "M" && pCode === "M") return "Still a mix, but frequencies may shift with opponent tendencies.";

  const isRFI = scenarioKey.includes("_RFI");
  const isDef = scenarioKey.startsWith("BB_") || scenarioKey.startsWith("SB_");
  const p = PERSONA_CODE[personaSel?.value || "Standard"] || "STD";

  if(isRFI){
    if(p === "TIGHT") return "Tight table: fewer steals succeed and pots play tougher → trim marginal opens.";
    if(p === "LOOSE") return "Loose table: wider defenses and more postflop mistakes → open slightly wider for EV.";
    if(p === "AGGRO3B") return "Aggro 3-bettor: more pressure behind → tighten marginal opens / favor hands that continue well.";
    if(p === "LIMPER") return "Passive/limpy dynamics: opens get called more → prioritize hands that realize equity well.";
  }

  if(isDef){
    if(p === "TIGHT") return "Tight opponents: narrower ranges and less spew → defend tighter, bluff less.";
    if(p === "LOOSE") return "Loose opponents: wider opens and more mistakes → defend wider and realize more equity.";
    if(p === "AGGRO3B") return "Aggro opponents: more pressure → shift some flats into raises and defend a bit wider.";
    if(p === "LIMPER") return "Passive opponents: less 3-bet pressure → more calls, fewer bluffs.";
  }

  return "Persona nudges the baseline frequencies based on tighter/looser and more/less aggressive opponents.";
}

function renderDeltaLine(hand, scenarioKey){
  const deltaEl = document.getElementById("selDelta");
  if(!deltaEl) return;

  const { baseDist, personaDist } = getBaseAndPersonaDistsForHand(hand, scenarioKey);

  const baseLine = `Standard: ${codeLabelFromDist(baseDist)}`;
  const personaName = personaSel?.value || "Standard";
  const personaLine = `${personaName}: ${codeLabelFromDist(personaDist)}`;
  const why = explainDelta(hand, scenarioKey, baseDist, personaDist);

  deltaEl.textContent = `${baseLine}\n${personaLine}\n${why}`;
  deltaEl.style.whiteSpace = "pre-line";
}

function updateSelectedHandPanel(scenarioKey){
  if(!selectedHandCode) return;

  const { map, notes, mixWeights } = getScenarioData(scenarioKey);
  const h = selectedHandCode;

  // If somehow missing, just clear
  if(!map || !map[h]){
    resetSelectedHandUI();
    return;
  }

  const aRaw = map[h];
  const d = (typeof aRaw === "string")
    ? actionToDist(h, aRaw, mixWeights)
    : normalizeDist(aRaw || dist("F", 1));

  const code = distToCode(d);
  selHand.textContent = h;

  if(code === "M"){
    selAct.textContent = `MIX (${distPretty(d)})`;
    const base = (notes && notes[h]) || defaultNoteFor("M", h, scenarioKey);
    selNote.textContent = `${base} Preferred: ${primaryAction(d)} • ${distPretty(d)}.`;
  } else {
    selAct.textContent = prettyAction(code);
    selNote.textContent = (notes && notes[h]) || defaultNoteFor(code, h, scenarioKey);
  }

  renderExplorerHandAwareness();
  renderDeltaLine(h, scenarioKey);
}

  
  // --- Helper: expand shorthand specs into a 169-hand action map ---
  // We store rules as arrays of tokens:
  //  - Pair ranges: "22+", "TT+"
  //  - Suited ranges: "A2s+", "K9s+", "Q9s+", "J9s+", "T8s+", "97s+", "86s+"
  //  - Offsuit ranges: "ATo+", "KTo+", "QTo+", "JTo", "KJo+", "QJo", "AJo+"
  //  - Specific combos: "KQs", "AQo" etc.

  function rankIndex(r){ return ranks.indexOf(r); }

function boardToInputString(cards){
  if (!Array.isArray(cards)) return "";
  return cards
    .map(c => (c && c.r && c.suit) ? `${c.r}${String(c.suit).toLowerCase()}` : "")
    .filter(Boolean)
    .join(" ");
}
  
  // ===== Postflop foundation: board parsing + texture classification =====

function parseBoard(input){
  if(!input) return null;
  const s = input.trim().toUpperCase();
  const clean = s.replace(/\s+/g, "");

  // Accept explicit cards: "AH7D2C" or "Ah 7d 2c"
  const cardRe = /^([AKQJT98765432])([SHDC])([AKQJT98765432])([SHDC])([AKQJT98765432])([SHDC])$/;
  const m = clean.match(cardRe);
  if(m){
    return [
      { r:m[1], suit:m[2] },
      { r:m[3], suit:m[4] },
      { r:m[5], suit:m[6] },
    ];
  }


  // Accept shorthand ranks with optional tone marker: A72R, T98SS, KQ7
  const sh = clean.match(/^([AKQJT98765432])([AKQJT98765432])([AKQJT98765432])(R|SS|TT)?$/);
  if(sh){
    const r1=sh[1], r2=sh[2], r3=sh[3];
    const tone = sh[4] || "";
    let suits;
    if(tone === "R"){
      suits = ["S","H","D"]; // rainbow
    } else if(tone === "SS" || tone === "TT"){
      suits = ["S","S","H"]; // two-tone
    } else {
      suits = ["S","H","D"]; // unknown -> treat as rainbow-ish
    }
    return [{r:r1,suit:suits[0]},{r:r2,suit:suits[1]},{r:r3,suit:suits[2]}];
  }

  return null;
}

// ===== Hand vs Board Evaluation =====

function evaluateHandOnBoard(handCode, board){
  if(!handCode || !board || board.length !== 3) return null;

  const R = {"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,"T":10,"J":11,"Q":12,"K":13,"A":14};

  const hr1 = handCode[0];
  const hr2 = handCode[1];
  const suitedFlag = handCode.length === 3 ? handCode[2] : null; // "s" or "o" or null for pairs

  const hRanks = [R[hr1], R[hr2]];
  const isPair = hr1 === hr2;
  const isSuited = suitedFlag === "s";

  const bRanks = board.map(c => R[String(c.r).toUpperCase()]);
  const bSuits = board.map(c => String(c.suit).toLowerCase());

  const allRanks = [...hRanks, ...bRanks];

  // ===== Made hand detection =====
  const rankCounts = {};
  for(const x of allRanks) rankCounts[x] = (rankCounts[x] || 0) + 1;
  const counts = Object.values(rankCounts).sort((a,b)=>b-a);

  const bSorted = [...bRanks].sort((a,b)=>b-a);
  const topBoard = bSorted[0];
  const midBoard = bSorted[1];
  const lowBoard = bSorted[2];

  if(counts[0] === 4) return { type:"Quads" };
  if(counts[0] === 3 && counts[1] === 2) return { type:"Full house" };

  if(counts[0] === 3){
    if(isPair && bRanks.includes(hRanks[0])) {
      if(hRanks[0] === topBoard) return { type:"Top set" };
      if(hRanks[0] === midBoard) return { type:"Middle set" };
      return { type:"Bottom set" };
    }
    return { type:"Trips" };
  }

  if(counts[0] === 2 && counts[1] === 2){
    return { type:"Two pair" };
  }

  if(counts[0] === 2){
    if(isPair){
      if(hRanks[0] > topBoard) return { type:"Overpair" };
      if(hRanks[0] < topBoard) return { type:"Underpair" };
      return { type:"One pair" };
    }

    const pairRank = hRanks.find(r => bRanks.includes(r));
    const kicker = hRanks.find(r => r !== pairRank) || 0;

    if(pairRank === topBoard){
      return kicker >= 12 ? { type:"Top pair (good kicker)" } : { type:"Top pair (weak kicker)" };
    }
    if(pairRank === midBoard) return { type:"Middle pair" };
    if(pairRank === lowBoard) return { type:"Bottom pair" };
    return { type:"One pair" };
  }

  // ===== Draw detection (no made hand) =====

  // --- Flush draw / backdoor flush (limited because hand has no suit info) ---
  // We treat suited hands as:
  // - "Flush draw possible" if board is two-tone (2 of one suit)
  // - "Backdoor flush possible" if board is rainbow (but hand is suited)
  const suitCounts = {};
  for(const s of bSuits) suitCounts[s] = (suitCounts[s] || 0) + 1;
  const maxSuit = Math.max(...Object.values(suitCounts));
  const boardMonotone = maxSuit === 3;
  const boardTwoTone  = maxSuit === 2;
  const boardRainbow  = maxSuit === 1;

  let flushClass = null;
  if(isSuited){
    if(boardTwoTone) flushClass = "Flush draw possible";
    else if(boardRainbow) flushClass = "Backdoor flush possible";
    else if(boardMonotone) flushClass = "Flush draw unlikely (monotone)";
  }

  // --- Straight draw (OESD / gutshot / backdoor) ---
  const uniq = [...new Set(allRanks)].sort((a,b)=>a-b);

  // Helper: treat Ace as low too (for wheel)
  const uniqWithWheel = uniq.includes(14) ? [...new Set([...uniq, 1])].sort((a,b)=>a-b) : uniq;

  function straightDrawType(vals){
    // Look at 5-card windows; count how many ranks we have in the window
    // 4/5 => straight draw (missing 1): OESD or gutshot
    // 3/5 => backdoor straight possible (needs runner-runner)
    let best = { type:null, missing:99 };

    for(let start=1; start<=10; start++){
      const window = [start, start+1, start+2, start+3, start+4];
      const have = window.filter(x => vals.includes(x));
      const miss = window.filter(x => !vals.includes(x));
      const haveN = have.length;
      const missN = miss.length;

      if(haveN >= 4){
        // missing one rank: determine OESD vs gutshot
        // OESD if missing is at an end (start or start+4)
        const m = miss[0];
        const isOESD = (m === start || m === start+4);
        const t = isOESD ? "OESD" : "Gutshot";
        if(missN < best.missing){
          best = { type:t, missing:missN };
        }
      } else if(haveN === 3){
        // backdoor candidate (runner-runner)
        if(best.type === null){
          best = { type:"Backdoor straight possible", missing:missN };
        }
      }
    }

    return best.type;
  }

  const sd = straightDrawType(uniqWithWheel);

  // Combine draw categories
  const hasStrongStraight = (sd === "OESD");
  const hasAnyStraight = !!sd && sd !== "Backdoor straight possible";
  const hasBackdoorStraight = (sd === "Backdoor straight possible");

  const hasFD = (flushClass === "Flush draw possible");
  const hasBDFD = (flushClass === "Backdoor flush possible");

  // Combo draw: FD + (OESD/gutshot)
  if(hasFD && hasAnyStraight) return { type:"Strong draw", detail:`${flushClass} + ${sd}` };
  if(hasFD) return { type:"Draw", detail: flushClass };
  if(hasStrongStraight) return { type:"Draw", detail:"OESD" };
  if(sd === "Gutshot") return { type:"Draw", detail:"Gutshot" };
  if(hasBDFD && hasBackdoorStraight) return { type:"Backdoor draw", detail:"Backdoor flush + backdoor straight possible" };
  if(hasBDFD) return { type:"Backdoor draw", detail:"Backdoor flush possible" };
  if(hasBackdoorStraight) return { type:"Backdoor draw", detail:"Backdoor straight possible" };

  return { type:"Air" };
}




function boardTexture(cards){
  if(!cards || cards.length !== 3) return null;

  const ranks3 = cards.map(c=>c.r);
  const suits3 = cards.map(c=>c.suit);

  // Suit texture
  const suitCounts = {};
  for(const su of suits3) suitCounts[su] = (suitCounts[su]||0)+1;
  const maxSuit = Math.max(...Object.values(suitCounts));
  const monotone = maxSuit === 3;
  const twoTone  = maxSuit === 2;
  const rainbow  = maxSuit === 1;

  // Paired / trips
  const rankCounts = {};
  for(const r of ranks3) rankCounts[r] = (rankCounts[r]||0)+1;
  const counts = Object.values(rankCounts).sort((a,b)=>b-a);
  const trips = counts[0] === 3;
  const paired = counts[0] === 2;

  // Convert ranks to pip values for gap/connectivity logic
  const pip = r=>{
    if(r==="A") return 14;
    if(r==="K") return 13;
    if(r==="Q") return 12;
    if(r==="J") return 11;
    if(r==="T") return 10;
    return Number(r);
  };
  const p = ranks3.map(pip).sort((a,b)=>b-a);

  const gap1 = p[0]-p[1]-1;
  const gap2 = p[1]-p[2]-1;
  const maxGap = Math.max(gap1, gap2);

  const straighty = !paired && !trips && (p[0]-p[2] <= 5);

  const broadwayHeavy = ranks3.filter(r=>["A","K","Q","J","T"].includes(r)).length >= 2;
  const lowHeavy = ranks3.filter(r=>["2","3","4","5","6"].includes(r)).length >= 2;

  // Wetness score (0..100) for bucketing
  let wet = 0;
  if(monotone) wet += 30;
  else if(twoTone) wet += 18;

  if(straighty) wet += 22;
  else if(maxGap <= 1) wet += 14;

  if(paired) wet -= 12;
  if(trips) wet -= 18;

  if(broadwayHeavy) wet += 6;
  if(lowHeavy) wet += 4;

  wet = Math.max(0, Math.min(100, wet));

    let textureLabel = "Semi-wet";
  if(trips || paired) textureLabel = "Paired";
  else if(monotone) textureLabel = "Monotone";
  else if(wet <= 18) textureLabel = "Dry";
  else if(wet >= 45) textureLabel = "Wet";

  return {
    ranks: ranks3.join(""),
    monotone, twoTone, rainbow,
    paired, trips,
    straighty,
    broadwayHeavy, lowHeavy,
    wetness: wet,
    textureLabel
  };

}

function spotTypeFromScenario(scenarioKey){
  // SRP RFI spots: you are the preflop raiser (c-betting)
  if(scenarioKey && scenarioKey.includes("_RFI")){
    return { type:"SRP_RAISED_PF" };
  }
  // BB defend spots: you are the defender
  if(scenarioKey && scenarioKey.startsWith("BB_vs_")){
    return { type:"SRP_DEFENDED_BB" };
  }
  // SB 3bet/fold spots: separate ruleset later
  if(scenarioKey && scenarioKey.startsWith("SB_vs_")){
    return { type:"3BP_SBET" };
  }
  return { type:"UNKNOWN" };
}

function bumpFreq(label, delta){
  const order = ["Low", "Medium", "High"];
  let i = order.indexOf(label);
  if(i < 0) i = 1;
  i = Math.max(0, Math.min(order.length - 1, i + delta));
  return order[i];
}

function bumpSize(label, delta){
  const order = ["Small", "Medium", "Large"];
  let i = order.indexOf(label);
  if(i < 0) i = 1;
  i = Math.max(0, Math.min(order.length - 1, i + delta));
  return order[i];
}

  

function cbetPlanSRP(texture, personaCode){
  if(!texture) return null;

  // --- Base plan from texture ---
  let plan;

  // Paired/dry boards => high small
  if((texture.paired || texture.trips) && texture.wetness <= 20){
    plan = {
      freqLabel: "High",
      sizeLabel: "Small",
      why: "Paired/dry boards miss most ranges — range-bet small at high frequency."
    };
  }
  // Very dry rainbow/unconnected => high small
  else if(texture.rainbow && !texture.straighty && texture.wetness <= 18){
    plan = {
      freqLabel: "High",
      sizeLabel: "Small",
      why: "Dry rainbow boards favor the preflop raiser — small c-bets win often."
    };
  }
  // Monotone => lower freq, small size
  else if(texture.monotone){
    plan = {
      freqLabel: "Low",
      sizeLabel: "Small",
      why: "Monotone boards reduce fold equity — bet less often and keep size small."
    };
  }
  // Very wet/connected => lower freq, larger size when betting
  else if(texture.wetness >= 45 || texture.straighty){
    plan = {
      freqLabel: "Low",
      sizeLabel: "Large",
      why: "Wet/connected boards hit defenders — check more; when betting, go more polarized."
    };
  }
  // Middle textures
  else {
    plan = {
      freqLabel: "Medium",
      sizeLabel: (texture.twoTone ? "Medium" : "Small"),
      why: "Mixed texture — mix bets and checks; size up a bit if draw-heavy."
    };
  }

  // --- Persona adjustment (light, practical) ---
  // Interpret persona as opponent tendencies in this spot.
  // Tight: overfolds / under-defends -> bet more, smaller
  // Loose: calls wider -> bet less, bigger when you do
  // Aggro3B: fights back / floats/raises -> bet less, more polarized
  // Limper: passive/cally -> bet more on dry; not much on wet
  const p = personaCode || "STD";

  if(p === "TIGHT"){
    plan.freqLabel = bumpFreq(plan.freqLabel, +1);
    plan.sizeLabel = bumpSize(plan.sizeLabel, -1);
    plan.why += " vs Tight: more fold equity → c-bet a bit more, keep it small.";

  } else if(p === "LOOSE"){
    plan.freqLabel = bumpFreq(plan.freqLabel, -1);
    plan.sizeLabel = bumpSize(plan.sizeLabel, +1);
    plan.why += " vs Loose: gets called wider → c-bet a bit less; when betting, size up.";

  } else if(p === "AGGRO3B"){
    plan.freqLabel = bumpFreq(plan.freqLabel, -1);
    plan.sizeLabel = bumpSize(plan.sizeLabel, +1);
    plan.why += " vs Aggro: more resistance → check more; bets trend more polarized.";

  } else if(p === "LIMPER"){
    // Only boost frequency on drier boards; don’t force it on wet textures
    if(texture.wetness <= 30){
      plan.freqLabel = bumpFreq(plan.freqLabel, +1);
      plan.sizeLabel = bumpSize(plan.sizeLabel, -1);
      plan.why += " vs Passive: take stabs on dry boards; keep sizing small.";
    } else {
      plan.why += " vs Passive: still respect wet boards—don’t auto-stab into strong continues.";
    }
  }

  return plan;
}

  
// ===== /Postflop foundation =====


  function canonicalHand(code){
  if(!code) return code;
  if(code.length === 2) return code; // pairs like "77"
  const a = code[0], b = code[1], s = code[2];
  const ia = rankIndex(a), ib = rankIndex(b);
  return (ia <= ib) ? (a + b + s) : (b + a + s);
}
  
  function allHands(){
  const hands=[];
  for(let i=0;i<ranks.length;i++){
    for(let j=0;j<ranks.length;j++){
      const a=ranks[i], b=ranks[j];
      if(i===j) hands.push(a+b);
      else if(i<j) hands.push(canonicalHand(a+b+"s"));
      else hands.push(canonicalHand(a+b+"o"));
    }
  }
  return hands;
}


  function inPairPlus(hand, startPair){
    // hand like "77"; startPair like "TT" means TT, JJ, QQ, KK, AA
    if(hand.length!==2 || hand[0]!==hand[1]) return false;
    const h=rankIndex(hand[0]);
    const s=rankIndex(startPair[0]);
    return h<=s; // A is index 0 (stronger), so <= means higher/equal strength
  }

  function expandPairPlus(token){
    const base=token.slice(0,2); // e.g. "22"
    const res=[];
    for(const r of ranks){
      const h=r+r;
      if(inPairPlus(h, base)) res.push(h);
    }
    return res;
  }

  function expandSuitedPlus(token){
    // e.g. "A7s+" => A7s..A2s? careful: plus means stronger kicker (closer to A)
    // We'll interpret as: same first rank, second rank from given up to (but not including first rank)
    const a=token[0];
    const b=token[1];
    const res=[];
    const ai=rankIndex(a);
    const bi=rankIndex(b);
    for(let j=bi; j>ai; j--){ // toward stronger kicker (lower index)
      const kicker=ranks[j];
      res.push(a+kicker+"s");
    }
    return res;
  }

  function expandOffsuitPlus(token){
    // e.g. "ATo+" => ATo, AJo, AQo, AKo
    const a=token[0];
    const b=token[1];
    const ai=rankIndex(a);
    const bi=rankIndex(b);
    const res=[];
    for(let j=bi; j>ai; j--){
      const kicker=ranks[j];
      res.push(a+kicker+"o");
    }
    return res;
  }

  function normalizeToken(tok){
    return tok.replace(/\s+/g, "");
  }

  function applyTokens(map, tokens, actionOrDist){
  const distObj = (typeof actionOrDist === "string")
    ? dist(actionOrDist, 1)
    : normalizeDist(actionOrDist);

  for(let tok of tokens){
    tok = normalizeToken(tok);
    if(!tok) continue;

    const setHand = (h)=>{
      h = canonicalHand(h);
      map[h] = normalizeDist(distObj);
    };

    if(/^[2-9TJQKA]{2}\+$/.test(tok)){
      // pair+
      expandPairPlus(tok).forEach(setHand);

    } else if(/^[2-9TJQKA]{2}s\+$/.test(tok)){
      expandSuitedPlus(tok).forEach(setHand);

    } else if(/^[2-9TJQKA]{2}o\+$/.test(tok)){
      expandOffsuitPlus(tok).forEach(setHand);

    } else if(/^[2-9TJQKA]{2}$/.test(tok) || /^[2-9TJQKA]{2}[so]$/.test(tok)){
      setHand(tok);

    } else {
      console.warn("Unrecognized token:", tok);
    }
  }
}


function buildRange(def){
  const map = {};
  const notes = def.notes || {};

  // Default every hand to FOLD as a distribution
  allHands().forEach(h => map[h] = dist("F", 1));

  // Apply base actions (as 100% distributions)
  if(def.calls)  applyTokens(map, def.calls, dist("C", 1));
  if(def.raises) applyTokens(map, def.raises, dist("R", 1));

  // Mixes override base:
  // Supports:
  //  mixes: ["A2s","A5s"]  (defaults to 50/50 R/C)
  //  mixes: { "A2s": {R:0.25,C:0.75}, ... } (explicit)
  if(Array.isArray(def.mixes)){
    for(const h of def.mixes){
      const hh = canonicalHand(h);
      // default mix is Raise/Call 50/50
      map[hh] = normalizeDist({ R:0.5, C:0.5, F:0 });
    }
  } else if(def.mixes && typeof def.mixes === "object"){
    for(const h in def.mixes){
      const hh = canonicalHand(h);
      // if mixes[h] is a dist-like object, use it; else default to 50/50 R/C
      const d = def.mixes[h];
      if(d && typeof d === "object"){
        map[hh] = normalizeDist({ R:d.R||0, C:d.C||0, F:d.F||0 });
      } else {
        map[hh] = normalizeDist({ R:0.5, C:0.5, F:0 });
      }
    }
  }

  // Back-compat: if def.mixWeights exists, use it to update any MIX hands
  // (so you can keep your existing scenario defs unchanged)
  const mixWeights = def.mixWeights || {};
  for(const h in mixWeights){
    const hh = canonicalHand(h);
    const w = mixWeights[h] || {};
    // treat weights as R/C only unless F provided
    map[hh] = normalizeDist({
      R: Number(w.R ?? 0),
      C: Number(w.C ?? 0),
      F: Number(w.F ?? 0),
    });
  }

  // Return both:
  // - map: distributions for every hand
  // - mixWeights: derived (R/C) weights for display overlays, badges, etc.
  const derivedMixWeights = {};
  for(const h in map){
    const d = normalizeDist(map[h]);
    if(isMix(d)){
      derivedMixWeights[h] = { R:d.R, C:d.C, F:d.F };
    }
  }

  return { map, notes, mixWeights: derivedMixWeights };
}


  // --- Scenarios ---
  // You can add more simply by extending this object.
  const scenarios = {
    "BTN_RFI": {
      name: "BTN Open (RFI)",
      kicker: "8-max • rake/ante aware • open ~3x",
      def: {
        raises: [
          "22+",
          "A2s+", "A2o+", // all aces
          "K8s+", "KTo+",
          "Q9s+", "QTo+",
          "J9s+", "JTo",
          "T8s+",
          "97s+",
          "86s+"
        ],
        notes: {
          "AJo":"Prefer 3-bet-or-fold vs earlier opens; as RFI it’s strong enough.",
          "KTo":"Late-position steal; be ready to barrel selectively on good textures.",
          "86s":"Lowest suited connector we open here in this rake environment."
        }
      }
    },

    "CO_RFI": {
      name: "CO Open (RFI)",
      kicker: "8-max • open ~3x",
      def: {
        raises: [
          "22+",
          "A7s+", "ATo+",
          "K9s+", "KJo+",
          "Q9s+", "QJo",
          "J9s+",
          "T9s",
          "98s"
        ],
        notes: {
          "KJo":"Often a fold vs 3-bet OOP; don’t overcall with it.",
          "A7s":"Good wheel/backdoor properties; avoid calling 3-bets OOP too wide."
        }
      }
    },

    "HJ_RFI": {
      name: "HJ Open (RFI)",
      kicker: "8-max • open ~3.5x",
      def: {
        raises: [
          "22+",
          "A9s+", "ATo+",
          "KTs+", "KQo",
          "QTs+",
          "JTs",
          "T9s"
        ]
      }
    },

    "LJ_RFI": {
      name: "LJ / UTG+1 Open (RFI)",
      kicker: "8-max • open ~3.5x",
      def: {
        raises: [
          "22+",
          "ATs+", "AJo+",
          "KQs", "KJs",
          "QJs",
          "JTs"
        ]
      }
    },

    "UTG_RFI": {
      name: "UTG Open (RFI)",
      kicker: "8-max • rake-sensitive • open ~3.5–4x",
      def: {
        raises: [
          "22+",
          "AJs+", "AQo+",
          "KQs"
        ]
      }
    },

   "BB_vs_BTN_3x": {
  name: "BB Defend vs BTN Open (3x)",
  kicker: "Call with playable equity • 3-bet linear/value-heavy • some wheel-ace mixes",
  def: {
    raises: [
      "88+",
      "AJs+", "AQo+",
      "KQs",
      "KTs", "QTs", "JTs"
    ],

    // NOTE: A2s/A3s/A4s/A5s removed from calls because they are now explicit MIX hands
    calls: [
      "22+",
      "A6s+",
      "K9s+", "Q9s+", "J9s+",
      "T8s+", "97s+", "86s+",
      "KTo+", "QTo+", "JTo"
    ],

    mixes: ["A2s","A3s","A4s","A5s","K9s","Q9s"],
    mixWeights: {
      // wheel suited aces: mostly call, sometimes 3-bet bluff
      "A2s": { R: 0.25, C: 0.75 },
      "A3s": { R: 0.20, C: 0.80 },
      "A4s": { R: 0.30, C: 0.70 },
      "A5s": { R: 0.55, C: 0.45 },

      // light pressure vs wide BTN (keep these small so it’s not “spewy”)
      "K9s": { R: 0.15, C: 0.85 },
      "Q9s": { R: 0.10, C: 0.90 }
    },

    notes: {
      "A2s":"Mostly a call. Mix in some 3-bets as a blocker bluff vs wide BTN.",
      "A5s":"Higher 3-bet frequency than other wheel aces (best wheel/backdoor profile).",
      "K9s":"Mostly call; occasional 3-bet vs very wide BTN or players who overfold to 3-bets.",
      "Q9s":"Mostly call; sprinkle a few 3-bets if BTN is opening too wide.",
      "KTo":"Defend vs wide BTN opens; be cautious on K-high boards vs heavy barreling regs."
    }
  }
},


   "BB_vs_BTN_4x": {
  name: "BB Defend vs BTN Open (4x)",
  kicker: "Tighter vs bigger size • prioritize suited + connected • wheel aces mostly-call mixes",
  def: {
    raises: [
      "99+",
      "AJs+", "AQo+",
      "KQs",
      "KTs", "QTs", "JTs"
    ],

    // NOTE: remove A2s/A3s/A4s/A5s from the A2s+ bucket because they are explicit MIX hands now
    calls: [
      "22+",
      "A6s+",
      "KTs+", "QTs+", "JTs",
      "T9s", "98s", "87s",
      "KQo", "QJo", "JTo"
    ],

    mixes: ["A2s","A3s","A4s","A5s"],
    mixWeights: {
      // vs 4x: much more calling, very little 3-betting
      "A2s": { R: 0.10, C: 0.90 },
      "A3s": { R: 0.08, C: 0.92 },
      "A4s": { R: 0.12, C: 0.88 },
      "A5s": { R: 0.20, C: 0.80 }
    },

    notes: {
      "A2s":"Mostly call vs 4x. Tiny 3-bet frequency only vs wide BTN / strong fold-to-3b tendencies.",
      "A5s":"Still mostly call vs 4x; this is the one wheel ace that keeps some 3-bet mix.",
      "KQo":"Call some vs BTN 4x if BTN is wide and you play well postflop; otherwise mix to 3-bet/fold.",
      "87s":"Bottom of suited connector calls vs 4x; fold weaker gappers."
    }
  }
},


  "BB_vs_CO_3x": {
  name: "BB Defend vs CO Open (3x)",
  kicker: "CO is tighter than BTN • defend tighter • wheel aces mostly-call mixes",
  def: {
    raises: [
      "99+",
      "AQo+", "AJs+",
      "KQs",
      "KTs", "QTs", "JTs"
    ],

    // NOTE: remove A2s/A3s/A4s/A5s from the A2s+ bucket because they are explicit MIX hands now
    calls: [
      "22+",
      "A6s+",
      "KTs+", "QTs+", "JTs",
      "T9s", "98s",
      "KQo"
    ],

    mixes: ["A2s","A3s","A4s","A5s"],
    mixWeights: {
      // vs CO: less bluffing than BTN
      "A2s": { R: 0.15, C: 0.85 },
      "A3s": { R: 0.10, C: 0.90 },
      "A4s": { R: 0.15, C: 0.85 },
      "A5s": { R: 0.35, C: 0.65 }
    },

    notes: {
      "A2s":"Mostly call vs CO. Small 3-bet frequency as a blocker bluff.",
      "A5s":"The wheel ace that keeps the most 3-bet mix even vs CO.",
      "KQo":"Solid defend vs CO; be disciplined postflop on marginal top pair."
    }
  }
},



   "BB_vs_CO_4x": {
  name: "BB Defend vs CO Open (4x)",
  kicker: "Tightest of these spots • fewer offsuit continues • wheel aces mostly-call mixes",
  def: {
    raises: [
      "TT+",
      "AQo+", "AJs+",
      "KQs",
      "A5s", "A4s"
    ],

    // NOTE: remove A2s/A3s/A4s/A5s from the A2s+ bucket because they are explicit MIX hands now
    calls: [
      "22+",
      "A6s+",
      "KQs", "KJs",
      "QJs", "JTs",
      "T9s", "98s"
    ],

    mixes: ["A2s","A3s","A4s","A5s"],
    mixWeights: {
      // vs CO 4x: very low 3-bet bluffing frequency
      "A2s": { R: 0.05, C: 0.95 },
      "A3s": { R: 0.04, C: 0.96 },
      "A4s": { R: 0.06, C: 0.94 },
      "A5s": { R: 0.10, C: 0.90 }
    },

    notes: {
      "A2s":"Almost always call vs CO 4x; 3-bet frequency is tiny.",
      "A5s":"Still mostly call; slight 3-bet mix remains as a better bluff candidate."
    }
  }
},


    "SB_vs_BTN_3betFold": {
      name: "SB vs BTN (3-bet or Fold)",
      kicker: "No flatting in SB • 3-bet linear + suited blockers",
      def: {
        raises: [
          "88+",
          "AJs+", "AQo+",
          "KQs",
          "A2s+",   
          "KTs", "QTs", "JTs"
        ],
        notes: {
          "A2s":"Use as 3-bet bluff vs wide BTN. Suited wheel aces play well as blockers.",
          "KTs":"Good semi-bluff 3-bet candidate; plays fine when called."
        }
      }
    }
  };

  const PERSONAS = {
  Standard: { label: "Standard" },
  Tight:    { label: "Tight" },
  Loose:    { label: "Loose" },
  "Aggro 3bettor": { label: "Aggro 3bettor" },
  Limper:   { label: "Limper" },
};

// Applies persona adjustments to a scenario's def BEFORE buildRange()
function applyPersona(def, scenarioKey, persona){
  // Always clone so we don't mutate base scenario defs
  const out = JSON.parse(JSON.stringify(def || {}));
  const p = persona || "Standard";

  // For now: only adjust RFI scenarios
  const isRFI = scenarioKey.includes("_RFI");
  if(!isRFI || p === "Standard") return out;

  out.raises = out.raises || [];
  out.calls  = out.calls  || [];
  out.mixes  = out.mixes  || [];
  out.mixWeights = out.mixWeights || {};
  out.notes  = out.notes  || {};

  if(p === "Tight"){
    // Trim weakest opens
    const remove = ["86s+", "97s+", "T8s+", "JTo", "QTo+", "KTo+"];
    out.raises = out.raises.filter(t => !remove.includes(t));
    out.notes.__persona = "Tight: trims marginal suited connectors + weakest offsuit opens.";

  } else if(p === "Loose"){
    // Add a few extra steals/combos (kept conservative)
    const add = ["54s", "65s", "76s", "T7s", "98o"];
    for(const t of add) if(!out.raises.includes(t)) out.raises.push(t);
    out.notes.__persona = "Loose: adds a few extra steals/combos for wider opening.";

  }

  return out;
}

  // ===== Persona variability model (probability transform) =====

// A light, low-stakes oriented model:
// - Tight: folds more marginals, bluffs less
// - Loose: calls wider, folds less, raises slightly more but not maniac
// - Aggro 3bettor: shifts more of playable hands into raise/3b buckets
// - Limper: (for now) behaves like loose-passive from our POV (more calls, less 3b)
//   NOTE: true "limper" exploitation needs limp scenarios; we’ll add those later.

// Map dropdown labels -> internal model codes
const PERSONA_CODE = {
  "Standard": "STD",
  "Tight": "TIGHT",
  "Loose": "LOOSE",
  "Aggro 3bettor": "AGGRO3B",
  "Limper": "LIMPER",
};
  
  const PERSONA_MODELS = {
  STD:    { foldBias: 0.00, callBias: 0.00, raiseBias: 0.00, bluffBias: 0.00 },
  TIGHT:  { foldBias: 0.20, callBias:-0.10, raiseBias:-0.05, bluffBias:-0.25 },
  LOOSE:  { foldBias:-0.25, callBias: 0.25, raiseBias: 0.05, bluffBias:-0.05 },
  AGGRO3B:{ foldBias:-0.10, callBias:-0.10, raiseBias: 0.25, bluffBias: 0.20 },
  LIMPER: { foldBias:-0.15, callBias: 0.30, raiseBias:-0.10, bluffBias:-0.20 },
};

// Hand classification helpers (simple but effective)
function isPair(h){ return h.length === 2; }
function isSuited(h){ return h.length === 3 && h[2] === "s"; }
function isOffsuit(h){ return h.length === 3 && h[2] === "o"; }
function ranksOf(h){
  if(isPair(h)) return [h[0], h[1]];
  return [h[0], h[1]];
}
function isBroadway(r){ return ["A","K","Q","J","T"].includes(r); }
function gapSize(h){
  if(isPair(h)) return 0;
  const a = rankIndex(h[0]);
  const b = rankIndex(h[1]);
  return Math.abs(a - b) - 1; // 0=connectors, 1=1-gap, etc (A,K => big gap)
}
function isConnector(h){
  if(isPair(h)) return false;
  const g = gapSize(h);
  return g === 0;
}
function isWheelAce(h){
  if(isPair(h) || h[0] !== "A") return false;
  return ["2","3","4","5"].includes(h[1]);
}

  function handCodeFromMapVal(v){
  const d = (typeof v === "object") ? normalizeDist(v) : dist(v || "F", 1);
  return distToCode(d); // "R"|"C"|"F"|"M"
}


// Convert an action code / "M" + mixWeights into a dist object
function actionToDist(h, aRaw, mixWeights){
  if(typeof aRaw === "object") return normalizeDist(aRaw);
  const a = aRaw || "F";
  if(a === "R") return dist("R", 1);
  if(a === "C") return dist("C", 1);
  if(a === "F") return dist("F", 1);
  // MIX
  const w = mixWeights?.[h] || { R: 0.5, C: 0.5 };
  return normalizeDist({ R: Number(w.R ?? 0.5), C: Number(w.C ?? 0.5), F: 0 });
}

// A small utility to shift probability mass between components
function moveMass(d, from, to, amt){
  amt = Math.max(0, Math.min(1, amt));
  const take = Math.min(d[from], amt);
  d[from] -= take;
  d[to] += take;
  return d;
}

  // 0..1 where 1 = very marginal (more likely to fold), 0 = premium (more likely to raise)
function marginalScore(hand){
  const [r1, r2] = ranksOf(hand);
  const broad = isBroadway(r1) && isBroadway(r2);
  const pair = isPair(hand);
  const suited = isSuited(hand);
  const offsuit = isOffsuit(hand);
  const conn = isConnector(hand);
  const wheelA = isWheelAce(hand);

  let m = 0.55;
  if(pair) m -= 0.30;
  if(broad) m -= 0.20;
  if(suited) m -= 0.10;
  if(offsuit) m += 0.10;
  if(conn) m -= 0.08;
  if(gapSize(hand) >= 2 && !broad) m += 0.12;
  if(wheelA && suited) m -= 0.05;

  return Math.max(0.05, Math.min(0.95, m));
}

  
// Core transform:
// - starts from base dist (R/C/F)
// - persona nudges it, with stronger effects on "marginal" buckets
function transformDistForPersona(hand, baseDist, scenarioKey, personaCode){
  const m = PERSONA_MODELS[personaCode] || PERSONA_MODELS.STD;
  const d = normalizeDist(baseDist);

  if(personaCode === "STD") return d;

  const isRFI = scenarioKey.includes("_RFI");
  const isBB  = scenarioKey.startsWith("BB_");
  const isSB3B = scenarioKey.includes("SB_vs_BTN_");

  // Identify marginality: offsuit gappers are most marginal; pairs/broadways least marginal
  const [r1, r2] = ranksOf(hand);
  const broad = isBroadway(r1) && isBroadway(r2);
  const pair = isPair(hand);
  const suited = isSuited(hand);
  const offsuit = isOffsuit(hand);
  const conn = isConnector(hand);
  const wheelA = isWheelAce(hand);

  // Base marginal score in [0..1]
  let marginal = 0.55;
  if(pair) marginal -= 0.30;
  if(broad) marginal -= 0.20;
  if(suited) marginal -= 0.10;
  if(offsuit) marginal += 0.10;
  if(conn) marginal -= 0.08;
  if(gapSize(hand) >= 2 && !broad) marginal += 0.12;
  if(wheelA && suited) marginal -= 0.05;

  marginal = Math.max(0.05, Math.min(0.95, marginal));

  // Fold bias: tight folds more, loose folds less; applied more to marginal hands
  const foldAmt = Math.abs(m.foldBias) * (0.10 + 0.35*marginal);
  if(m.foldBias > 0){
    // move from C and R into F
    moveMass(d, "C", "F", foldAmt * 0.6);
    moveMass(d, "R", "F", foldAmt * 0.4);
  } else if(m.foldBias < 0){
    // move from F into C (mostly) and a bit into R for RFI
    const intoR = isRFI ? 0.25 : 0.10;
    moveMass(d, "F", "C", foldAmt * (1 - intoR));
    moveMass(d, "F", "R", foldAmt * intoR);
  }

  // Call bias: loose calls more, aggro calls less; BB spots amplify call bias
  let callAmt = Math.abs(m.callBias) * (0.08 + 0.30*marginal);
  if(isBB) callAmt *= 1.15;
  if(m.callBias > 0){
    moveMass(d, "F", "C", callAmt * 0.7);
    moveMass(d, "R", "C", callAmt * 0.3);
  } else if(m.callBias < 0){
    moveMass(d, "C", "F", callAmt * 0.6);
    moveMass(d, "C", "R", callAmt * 0.4);
  }

  // Raise/3bet bias: aggro shifts into R; tight shifts out of R
  let raiseAmt = Math.abs(m.raiseBias) * (0.06 + 0.22*(1 - marginal)); // more on strong-ish hands
  if(isSB3B) raiseAmt *= 1.10; // SB 3bet/fold spot
  if(m.raiseBias > 0){
    moveMass(d, "C", "R", raiseAmt * 0.7);
    moveMass(d, "F", "R", raiseAmt * 0.3);
  } else if(m.raiseBias < 0){
    moveMass(d, "R", "C", raiseAmt * 0.6);
    moveMass(d, "R", "F", raiseAmt * 0.4);
  }

  // Bluff bias: affects the margin between R and C/F on *marginal* hands
  const bluffAmt = Math.abs(m.bluffBias) * (0.05 + 0.28*marginal);
  if(m.bluffBias > 0){
    // more bluffs => move some C/F to R
    moveMass(d, "C", "R", bluffAmt * 0.55);
    moveMass(d, "F", "R", bluffAmt * 0.45);
  } else if(m.bluffBias < 0){
    // fewer bluffs => move some R to C/F
    moveMass(d, "R", "C", bluffAmt * 0.55);
    moveMass(d, "R", "F", bluffAmt * 0.45);
  }

  // ===== RFI clamp: no flatting when you're first in =====
  // Convert any call-mass into raise or fold based on marginality.
  if(isRFI){
    const mScore = marginalScore(hand); // 0 strong -> 1 marginal

    // threshold shifts by persona:
    // Tight folds more marginal hands; Loose/Aggro raise more marginal hands.
    let t = 0.55; // baseline
    if(personaCode === "TIGHT")  t -= 0.10;  // more call->fold
    if(personaCode === "LOOSE")  t += 0.10;  // more call->raise
    if(personaCode === "AGGRO3B") t += 0.12; // even more call->raise
    if(personaCode === "LIMPER") t -= 0.05;  // passive -> more folds

    // If hand is "strong enough" (low marginalScore), call-mass becomes raises.
    // If very marginal (high marginalScore), call-mass becomes folds.
    const callMass = d.C;

    if(callMass > 0){
      const toRaise = (mScore <= t);
      d.C = 0;
      if(toRaise) d.R += callMass;
      else d.F += callMass;
    }
  }

  return normalizeDist(d);
}


// Apply persona transform to an entire built range
function applyPersonaToBuiltRange(built, scenarioKey, personaCode){
  const baseMap = built.map || {};
  const baseNotes = built.notes || {};
  const baseMixWeights = built.mixWeights || {};

  const outMap = {};
  const outMixWeights = {};

  for(const h of Object.keys(baseMap)){
    const baseDist = actionToDist(h, baseMap[h], baseMixWeights);
    const d2 = transformDistForPersona(h, baseDist, scenarioKey, personaCode);

    outMap[h] = d2;

    // If it becomes MIX after transform, capture weights for UI
    if(distToCode(d2) === "M"){
      outMixWeights[h] = { R: d2.R, C: d2.C };
    }
  }

  // Notes: keep existing notes; add persona banner note in a safe key
  const notes = Object.assign({}, baseNotes);
  if(personaCode && personaCode !== "STD"){
    notes.__persona = `Persona applied: ${personaCode}`;
  }

  return { map: outMap, notes, mixWeights: outMixWeights };
}



  // --- UI rendering ---
  const scenarioSel = document.getElementById("scenario");
  const personaSel = document.getElementById("persona");

  const matrixEl = document.getElementById("matrix");
  const scenarioTitle = document.getElementById("scenarioTitle");
  const scenarioKicker = document.getElementById("scenarioKicker");
  const rangePct = document.getElementById("rangePct");
  const cntRaise = document.getElementById("cntRaise");
  const cntCall  = document.getElementById("cntCall");
  const cntMix   = document.getElementById("cntMix");
  const cntFold  = document.getElementById("cntFold");
  const selHand  = document.getElementById("selHand");
  const selAct   = document.getElementById("selAct");
  const selNote  = document.getElementById("selNote");
  const toastEl  = document.getElementById("toast");
  // Postflop UI elements
  const boardApply  = document.getElementById("boardApply");
  const postflopLine = document.getElementById("postflopLine");
  const selHandAwareness = document.getElementById("selHandAwareness");



  let currentBoard = null;


  let showLabels = true;
  let selectedHandCode = null; // currently-selected hand in Explorer


  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    setTimeout(()=> toastEl.classList.remove("show"), 1200);
  }

function renderExplorerHandAwareness(){
  if(!selHandAwareness) return;

  // Needs a selected hand + a picked flop
  const handCode = (selectedHandCode || "").trim(); // your existing selected-hand variable
 const flop = (getExplorerFlop() || []).filter(Boolean);


  if(!handCode){
    selHandAwareness.textContent = "Click a hand in the grid to see awareness.";
    return;
  }

  if(flop.length !== 3){
    selHandAwareness.textContent = "Pick a flop and click Apply to see hand awareness.";
    return;
  }

  try{
    // If you already have a real evaluator function, use it here instead.
    // We do a simple, reliable classification that matches your existing labels.
    const txt = classifyExplorerHandVsFlop(handCode, flop);
    selHandAwareness.textContent = txt || "—";
  }catch(e){
    selHandAwareness.textContent = "—";
  }
}

function classifyExplorerHandVsFlop(handCode, flopCards){
  // handCode like "KQo", "AJs", "77"
  const h = canonicalHand(handCode);
  if(!h) return "";

  const isPair = (h.length === 2);
  const r1 = h[0];
  const r2 = isPair ? h[1] : h[1];
  const suited = (!isPair && h[2] === "s");

function cardRank(c){
  if(!c) return "";
  if(typeof c === "string") return String(c)[0].toUpperCase();
  // card object shapes
  if(c.r) return String(c.r)[0].toUpperCase();
  if(c.rank) return String(c.rank)[0].toUpperCase();
  return "";
}

function cardSuit(c){
  if(!c) return "";
  if(typeof c === "string") return String(c)[1]?.toLowerCase() || "";
  if(c.s) return String(c.s)[0].toLowerCase();       // common short key
  if(c.suit) return String(c.suit)[0].toLowerCase(); // common long key
  return "";
}

const br = flopCards.map(cardRank).filter(Boolean);
const bs = flopCards.map(cardSuit).filter(Boolean);


  // sort board ranks high->low by your rankIndex() (A=0 strongest)
  const boardRanksSorted = br.slice().sort((a,b)=> rankIndex(a) - rankIndex(b));
  const top = boardRanksSorted[0];
  const mid = boardRanksSorted[1];
  const bot = boardRanksSorted[2];

  const countOnBoard = (rk)=> br.filter(x=>x===rk).length;
  const c1 = countOnBoard(r1);
  const c2 = isPair ? c1 : countOnBoard(r2);

  // Made hands first
  if(isPair){
    if(c1 >= 1) return "Set / trips (pocket pair hits board)";
    // overpair / underpair / middle pocket
    if(rankIndex(r1) < rankIndex(top)) return "Overpair";
    if(rankIndex(r1) > rankIndex(bot)) return "Underpair";
    return "Pocket pair (between board cards)";
  } else {
    const hit1 = c1 > 0;
    const hit2 = c2 > 0;

    if(hit1 && hit2) return "Two pair";
    if(hit1 || hit2){
      const pairRank = hit1 ? r1 : r2;
      const kicker   = hit1 ? r2 : r1;

      let which = "Pair";
      if(pairRank === top) which = "Top pair";
      else if(pairRank === mid) which = "Middle pair";
      else if(pairRank === bot) which = "Bottom pair";

      // “strong kicker” heuristic
      const strongKick = ["A","K","Q","J"].includes(kicker);
      if(which === "Top pair" && strongKick) return "Top pair (strong kicker)";
      if(which === "Top pair") return "Top pair";
      return which;
    }
  }

  // Draws / air (simple, but useful)
  const drawBits = [];


  // Straight draw (very lightweight)
  const uniqRanks = [...new Set([r1, r2, ...br])];
  const idxs = uniqRanks.map(rankIndex).filter(x=>Number.isFinite(x)).sort((a,b)=>a-b);

  // If 4 cards fall within a 5-rank window -> “straight draw possible”
  let straighty = false;
  for(let i=0;i<idxs.length;i++){
    const window = idxs.filter(x => x >= idxs[i] && x <= idxs[i] + 4);
    if(window.length >= 4){ straighty = true; break; }
  }
  if(straighty) drawBits.push("Straight draw possible");

  if(drawBits.length) return `Air (${drawBits.join(" • ")})`;
  return "Air";
}

function getExplorerFlop(){
  // Supports BOTH shapes:
  // 1) currentBoard = [{r,suit},...]
  // 2) currentBoard = { flop:[{r,suit},...], turn, river }
  if(!currentBoard) return null;

  if(Array.isArray(currentBoard)) return currentBoard;

  if(currentBoard && Array.isArray(currentBoard.flop)) return currentBoard.flop;

  return null;
}

  
  function renderPostflopAdvice(){
    if(!postflopLine) return;

    const scenarioKey = scenarioSel?.value || "";
    const spot = spotTypeFromScenario(scenarioKey);

    if(!currentBoard){
      postflopLine.textContent = "Enter a board to see a baseline plan.";
      return;
    }

  const flop = getExplorerFlop();
  const tex = flop ? boardTexture(flop) : null;

    if(!tex){
      postflopLine.textContent = "Could not parse board texture.";
      return;
    }

    if(spot.type === "SRP_RAISED_PF"){
      const personaCode = PERSONA_CODE[personaSel?.value || "Standard"] || "STD";
      const plan = cbetPlanSRP(tex, personaCode);

      const suitTxt = tex.monotone ? "Monotone" : (tex.twoTone ? "Two-tone" : "Rainbow");
      const pairTxt = tex.trips ? "Trips" : (tex.paired ? "Paired" : "Unpaired");
      const connTxt = tex.straighty ? "Connected" : "Unconnected";

      postflopLine.textContent =
        `Board: ${tex.ranks} • ${tex.textureLabel} (${suitTxt}, ${pairTxt}, ${connTxt}, wetness ${tex.wetness})\n` +
        `C-bet: ${plan.freqLabel} freq • Size: ${plan.sizeLabel}\n` +
        `${plan.why}`;

      postflopLine.style.whiteSpace = "pre-line";
      return;
    }


    if(spot.type === "SRP_DEFENDED_BB"){
      postflopLine.textContent = "BB defender spot: foundation coming next (check/call, check-raise, continues).";
      return;
    }

    if(spot.type === "3BP_SBET"){
      postflopLine.textContent = "3-bet pot logic is a separate ruleset — foundation comes after SRP.";
      return;
    }

// (debug logs removed)


    postflopLine.textContent = "Unsupported spot for postflop foundation (for now).";
  
    renderExplorerHandAwareness();
  }

  
  function handForCell(rowRank, colRank){
  const i = rankIndex(rowRank);
  const j = rankIndex(colRank);

  if(i === j) return rowRank + colRank;

  // Above diagonal = suited, below diagonal = offsuit
  const suited = i < j;
  const hi = i < j ? rowRank : colRank;
  const lo = i < j ? colRank : rowRank;

  return canonicalHand(hi + lo + (suited ? "s" : "o"));
}

function mixText(weights){
  const w = weights || { R: 0.5, C: 0.5 };
  const r = Math.round((w.R ?? 0.5) * 100);
  const c = Math.round((w.C ?? 0.5) * 100);
  return `Raise ${r}% / Call ${c}%`;
}

function mixPreferred(weights){
  const w = weights || { R: 0.5, C: 0.5 };
  return (w.C ?? 0.5) >= (w.R ?? 0.5) ? "CALL" : "RAISE";
}

  function mixIntensity(weights){
  const w = weights || { R: 0.5, C: 0.5 };
  const r = Math.max(0, Math.min(1, Number(w.R ?? 0.5)));
  // map raise-frequency to a nice visible overlay alpha
  // 0.0 -> 0.10, 1.0 -> 0.34
  return 0.10 + (0.24 * r);
}

   
  function prettyAction(code){
    return ACT[code]?.label || "—";
  }

function computeCounts(map){
  const counts = { R:0, C:0, M:0, F:0 };
  for(const h in map){
    const d = normalizeDist(map[h] || dist("F", 1));
    const a = distToCode(d);
    counts[a] = (counts[a] || 0) + 1;
  }
  return counts;
}



function rangeText(map){
  const groups = { R:[], C:[], M:[] };

  for(const [h, dRaw] of Object.entries(map)){
    const d = normalizeDist(dRaw || dist("F", 1));
    const a = distToCode(d);

    if(a === "R") groups.R.push(h);
    if(a === "C") groups.C.push(h);
    if(a === "M"){
      // show the actual frequencies, including fold-mixes if present
      groups.M.push(`${h} (${distPretty(d)})`);
    }
  }

  const fmt = arr => arr.slice().sort().join(", ");
  return `Raise: ${fmt(groups.R)}\n\nCall: ${fmt(groups.C)}\n\nMix: ${fmt(groups.M)}`;
}

function rangeTextWithContext(scenarioKey, personaLabel, map){
  const scName = scenarios[scenarioKey]?.name || scenarioKey;
  return `Scenario: ${scName}\nPersona: ${personaLabel}\n\n${rangeText(map)}`;
}



  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      toast("Copied range to clipboard");
    }catch(e){
      toast("Copy failed (browser permissions)");
      console.error(e);
    }
  }

function renderScenario(key){
  const sc = scenarios[key];
  const { map, notes, mixWeights } = getScenarioData(key);




    scenarioTitle.textContent = sc.name;
    scenarioKicker.textContent = sc.kicker;

    // Build matrix header row
    matrixEl.innerHTML = "";
    matrixEl.appendChild(hdrCorner());
    ranks.forEach(r=> matrixEl.appendChild(hdr(r)));

    // Body
    let selectedFirst = false;
    for(const rRow of ranks){
      matrixEl.appendChild(hdr(rRow));
      for(const rCol of ranks){
        const h = handForCell(rRow, rCol);
const aRaw = map[h];
const d = (typeof aRaw === "string")
  ? actionToDist(h, aRaw, mixWeights) // uses mixWeights for "M"
  : normalizeDist(aRaw || dist("F", 1));

const a = distToCode(d);              // R/C/F/M (for label logic if you want)
const prim = primaryAction(d);        // R/C/F (dominant action for border color)
const meta = ACT[prim] || ACT.F;

const el = document.createElement("div");
el.className = `cell ${meta.cls}`;
el.title = distPretty(d);
// Set proportional overlay variables (0..100)
el.style.setProperty("--r", (d.R * 100).toFixed(0));
el.style.setProperty("--c", (d.C * 100).toFixed(0));
el.style.setProperty("--f", (d.F * 100).toFixed(0));

// Add a mixed marker if it’s not a pure 100% action
if(isMix(d)) el.classList.add("isMixed");

if(selectedHandCode && h === selectedHandCode){
  el.classList.add("sel");
}



  if(a === "M"){
  const w = mixWeights?.[h] || { R: d.R, C: d.C }; // prefer scenario weights if present
  el.style.setProperty("--mixA", mixIntensity(w));
}

        
        const handLabel = displayHandLabel(rRow, rCol);
        el.innerHTML = `<div class="hand">${handLabel}</div>${showLabels ? `<div class="act">${a}</div>` : ""}`;

el.addEventListener("click", ()=>{
  selectedHandCode = h;
  updateSelectedHandPanel(key);
  toast(`${handLabel}: ${prettyAction(distToCode(d))}`);

  // --- TEMP: postflop hand evaluation debug ---
  // (debug logs removed to keep console clean)


});




        matrixEl.appendChild(el);
        if(!selectedFirst){
          selHand.textContent = "—";
          selAct.textContent = "—";
          selNote.textContent = "Click a cell";
          selectedFirst = true;
        }
      }
    }

    const counts = computeCounts(map);
    cntRaise.textContent = `${counts.R} combos`;
    cntCall.textContent  = `${counts.C} combos`;
    cntMix.textContent   = `${counts.M} combos`;
    cntFold.textContent  = `${counts.F} combos`;

    const playable = counts.R + counts.C + counts.M;
    const pct = (playable / 169 * 100).toFixed(1);
    if (rangePct) rangePct.textContent = `${pct}% of hands playable`;

    // Wire copy button

document.getElementById("copy").onclick = ()=> {
  const personaLabel = personaSel?.value || "Standard";
  const activeKey = (trainerView.style.display !== "none" && current?.scenarioKey)
    ? current.scenarioKey
    : scenarioSel.value;

  const { map } = getScenarioData(activeKey);
  copyToClipboard(rangeTextWithContext(activeKey, personaLabel, map));
};


  }

  function defaultNoteFor(action, hand, key){
    if(action==="R"){
      if(key.includes("RFI")) return "Open for value + steal equity; rake rewards taking initiative.";
      if(key.includes("BB")) return "3-bet (value/pressure). Prefer linear/value-heavy in this rake environment.";
      return "Raise/3-bet.";
    }
    if(action==="C") return "Call with playable equity; avoid dominated offsuit junk.";
    if(action==="M") return "Mix between call/raise based on opener tendencies and players behind.";
    return "Fold: too dominated / poor equity realization / rake-sensitive.";
  }

 function displayHandLabel(rowRank, colRank){
  const i = rankIndex(rowRank);
  const j = rankIndex(colRank);

  if(i === j) return rowRank + colRank;

  const suited = i < j;
  const hi = i < j ? rowRank : colRank;
  const lo = i < j ? colRank : rowRank;

  return canonicalHand(hi + lo + (suited ? "s" : "o"));
}

  function hdrCorner(){
    const el=document.createElement("div");
    el.className="hdrCell";
    el.textContent="";
    return el;
  }
  function hdr(t){
    const el=document.createElement("div");
    el.className="hdrCell";
    el.textContent=t;
    return el;
  }

  // Populate scenario selector
  const scenarioEntries = Object.entries(scenarios);
  for(const [key, sc] of scenarioEntries){
    const opt=document.createElement("option");
    opt.value=key;
    opt.textContent=sc.name;
    scenarioSel.appendChild(opt);
  }
  scenarioSel.value = scenarioEntries[0][0];

scenarioSel.addEventListener("change", () => {
  resetSelectedHandUI();
  renderScenario(scenarioSel.value);
  renderPostflopAdvice(); // <-- ADD THIS
});




  // Toggle labels
  document.getElementById("toggleLabels").addEventListener("click", (e)=>{
    showLabels = !showLabels;
    e.target.textContent = showLabels ? "Hide action labels" : "Show action labels";
    renderScenario(scenarioSel.value);
      renderPostflopAdvice();
  });

  // --- Trainer Mode ---
  const explorerView = document.getElementById("explorerView");
  const trainerView  = document.getElementById("trainerView");
  const modeBtn      = document.getElementById("modeBtn");

  const trainerScenarioSel = document.getElementById("trainerScenario");
  const trainerRandomness  = document.getElementById("trainerRandomness");
  const trainerNextBtn     = document.getElementById("trainerNext");
  const trainerPrompt      = document.getElementById("trainerPrompt");
  const trainerHandEl      = document.getElementById("trainerHand");
  const trainerResult      = document.getElementById("trainerResult");
  const trainerMatrix      = document.getElementById("trainerMatrix");
  const trainerRef         = document.getElementById("trainerRef");

  // Help modal elements
  const helpBtn = document.getElementById("helpBtn");
  const helpModal = document.getElementById("helpModal");
  const helpClose = document.getElementById("helpClose");
  const helpBackdrop = document.getElementById("helpBackdrop");
  const trainerResultTitle = document.getElementById("trainerResultTitle");
  const trainerBadge       = document.getElementById("trainerBadge");
  const trainerExplain     = document.getElementById("trainerExplain");
  const trainerChoiceLine  = document.getElementById("trainerChoiceLine");
  const trainerPersonaLine = document.getElementById("trainerPersonaLine");



  const btnRaise = document.getElementById("btnRaise");
  const btnCall  = document.getElementById("btnCall");
  const btnFold  = document.getElementById("btnFold");

  const stCorrect = document.getElementById("stCorrect");
  const stTotal   = document.getElementById("stTotal");
  const stAcc     = document.getElementById("stAcc");
  const stStreak  = document.getElementById("stStreak");
  const stMissed  = document.getElementById("stMissed");

  const trainerReset = document.getElementById("trainerReset");
  const trainerClearHistory = document.getElementById("trainerClearHistory");

// ===== Postflop Board Picker (52-card grid, auto-advance) =====
const boardPickBtn = document.getElementById("boardPick");
const boardModal = document.getElementById("boardModal");
const boardBackdrop = document.getElementById("boardBackdrop");
const boardClose = document.getElementById("boardClose");
const boardClear = document.getElementById("boardClear");
const boardUse = document.getElementById("boardUse");

const boardChipsEl = document.getElementById("boardChips");
const boardModalChipsEl = document.getElementById("boardModalChips");
const boardCardGridEl = document.getElementById("boardCardGrid");
const boardInputEl = document.getElementById("boardInput");
const boardApplyBtn = document.getElementById("boardApply");

const PF_SUITS = [
  { s:"h", label:"♥", cls:"pfRed" },
  { s:"d", label:"♦", cls:"pfRed" },
  { s:"c", label:"♣", cls:"pfBlack" },
  { s:"s", label:"♠", cls:"pfBlack" }
];
const PF_RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];

let flopSel = [null, null, null]; // each is like "Ah"
let flopActive = 0;               // 0..2


function chipLabel(card){
  if(!card) return "—";
  const r = card[0];
  const s = card[1];
  const suitObj = PF_SUITS.find(x => x.s === s);
  return suitObj ? (r + suitObj.label) : card;
}


function chipParts(card){
  if(!card) return { rank:"—", suitSym:"", suitCls:"" };
  const r = card[0];
  const s = card[1];
  const suitObj = PF_SUITS.find(x => x.s === s);
  return {
    rank: r,
    suitSym: suitObj ? suitObj.label : "",
    suitCls: suitObj ? suitObj.cls : ""
  };
}

function renderBoardSlots(){
  const el = document.getElementById("boardSlots");
  if(!el) return;

  el.innerHTML = "";

  for(let i=0;i<3;i++){
    const slot = document.createElement("div");
    slot.className = "boardSlot" + (i === flopActive ? " active" : "");

    if(flopSel[i]){
      const r = flopSel[i][0];
      const s = flopSel[i][1];
      const suitObj = PF_SUITS.find(x => x.s === s);
      slot.textContent = r + (suitObj?.label || s);
      slot.classList.add(suitObj?.cls || "black");
    } else {
      slot.textContent = "—";
    }

slot.addEventListener("click", () => {
  flopActive = i;
  openBoardModal();   // <-- open picker immediately
});


    el.appendChild(slot);
  }
}



function selectedSet(){
  return new Set(flopSel.filter(Boolean));
}

function renderCardGrid(){
  if(!boardCardGridEl) return;

  const used = selectedSet();
  boardCardGridEl.innerHTML = "";

  for(const suit of PF_SUITS){
    const row = document.createElement("div");
    row.className = "pfSuitRow";

    const suitLabel = document.createElement("div");
    suitLabel.className = "pfSuitLabel " + suit.cls;
    suitLabel.textContent = suit.label;
    row.appendChild(suitLabel);

    for(const r of PF_RANKS){
      const code = r + suit.s; // e.g. "Ah"
      const b = document.createElement("div");
      b.className = "pfCardBtn " + suit.cls;
      b.textContent = r + suit.label;

      if(used.has(code)) b.classList.add("disabled");
      if(flopSel.includes(code)) b.classList.add("selected");


      b.addEventListener("click", function(){
        if(used.has(code)) return;

        flopSel[flopActive] = code;

        const nextEmpty = flopSel.findIndex(function(x, idx){
          return !x && idx > flopActive;
        });
        if(nextEmpty !== -1) flopActive = nextEmpty;
        else flopActive = Math.min(2, flopActive + 1);

        renderAllBoardUI();
      });

      row.appendChild(b);
    }

    boardCardGridEl.appendChild(row);
  }
}

function renderBoardModalChips(){
  if(!boardModalChipsEl) return;

  boardModalChipsEl.innerHTML = "";

  for(let i=0;i<3;i++){
    const chip = document.createElement("div");
    chip.className = "pfChip" + (i === flopActive ? " active" : "");

    if(flopSel[i]){
      const r = flopSel[i][0];
      const s = flopSel[i][1];
      const suitObj = PF_SUITS.find(x => x.s === s);
      chip.innerHTML = `${r}<span class="${suitObj?.cls || ""}">${suitObj?.label || ""}</span>`;
    } else {
      chip.textContent = "—";
    }

    // Clicking a chip sets the active slot (nice UX inside modal)
    chip.addEventListener("click", () => {
      flopActive = i;
      renderAllBoardUI();
    });

    boardModalChipsEl.appendChild(chip);
  }
}

function renderBoardSummary(){
  const el = document.getElementById("boardSummary");
  if(!el) return;

  const txt = flopSel.every(Boolean) ? flopSel.join(" ") : "—";
  el.textContent = `Flop: ${txt}`;
}

  
function flopToInputString(){
  return flopSel.filter(Boolean).join(" ");
}

function flopSelToBoard(){
  // flopSel entries like "Ah", "7d", "2c"
  if(!flopSel.every(Boolean)) return null;
  return flopSel.map(cc => ({ r: cc[0].toUpperCase(), suit: cc[1] })); // suit stays lowercase
}

function updateApplyButton(){
  if(!boardApplyBtn) return;
  const ready = flopSel.every(Boolean);
  boardApplyBtn.classList.toggle("pfPrimary", ready);
  boardApplyBtn.disabled = !ready;
}

function renderAllBoardUI(){
  renderBoardSlots();
  renderBoardModalChips();   // <-- ADD THIS
  renderCardGrid();
  renderBoardSummary();

  const complete = flopSel.every(Boolean);
  if(boardUse){
    boardUse.disabled = !complete;
    boardUse.classList.toggle("pfPrimary", complete);
  }

  updateApplyButton();
}




function openBoardModal(){
  if(!boardModal) return;
  boardModal.style.display = "block";
  document.body.style.overflow = "hidden";
  renderAllBoardUI();
}

function closeBoardModal(){
  if(!boardModal) return;
  boardModal.style.display = "none";
  document.body.style.overflow = "";
}

if(boardPickBtn) boardPickBtn.addEventListener("click", openBoardModal);
if(boardClose) boardClose.addEventListener("click", closeBoardModal);
if(boardBackdrop) boardBackdrop.addEventListener("click", closeBoardModal);

if(boardClear){
  boardClear.addEventListener("click", function(){
    flopSel = [null,null,null];
    flopActive = 0;
    renderAllBoardUI();
  });
}

if(boardUse){
  boardUse.addEventListener("click", function(){
    closeBoardModal();
    if(boardApplyBtn) boardApplyBtn.click();
  });
}

if(boardApplyBtn){
  boardApplyBtn.addEventListener("click", function(){
    const board = flopSelToBoard();
    if(!board){
      toast("Pick 3 cards first");
      return;
    }

    currentBoard = board;
    renderPostflopAdvice();
    toast("Flop applied");
  });
}
  
// Initial render
renderAllBoardUI();

  
const cache = {}; // cacheKey -> {map, notes, mixWeights}

function getScenarioData(key){
  const personaLabel = personaSel?.value || "Standard";

const personaCode = PERSONA_CODE[personaSel?.value] || "STD";

  const cacheKey = `${key}__${personaLabel}`;

  if(!cache[cacheKey]){
    // 1) base range (optionally keep token-style persona edits too)
const defAdj = applyPersona(scenarios[key].def, key, personaLabel); // safe even if it only affects RFI
    const built = buildRange(defAdj);

    // 2) probability transform persona (THIS is the main new behavior)
    cache[cacheKey] = applyPersonaToBuiltRange(built, key, personaCode);
  }

  // console.log removed (keep console clean)


  return cache[cacheKey];
}




  // Populate trainer scenario dropdown
  function populateTrainerScenarios(){
    trainerScenarioSel.innerHTML = "";
    // default option: random among all
    const optAll = document.createElement("option");
    optAll.value = "__RANDOM__";
    optAll.textContent = "Random scenario";
    trainerScenarioSel.appendChild(optAll);

    for(const [key, sc] of Object.entries(scenarios)){
      const opt=document.createElement("option");
      opt.value=key;
      opt.textContent=sc.name;
      trainerScenarioSel.appendChild(opt);
    }
    trainerScenarioSel.value = "__RANDOM__";
  }

  // Session stats + missed list stored in localStorage (so it survives refresh)
  const LS_KEY = "preflopTrainer_v1";
  const session = {
    correct: 0,
    total: 0,
    streak: 0,
    missed: [] // array of strings like "BB vs BTN 3x: KTo (correct CALL)"
  };

  const LS_PERSONA = "preflopPersona_v1";

// ===== Hand Logger: data model (v0) =====
const LS_LOGGER = "handLogger_v0";

let loggerState = {
  sessions: [],
  activeSessionId: null,

  table: {
    maxPlayers: 8,
    heroSeat: 0,
    uiMode: "BTN",
    selectedActorPos: null,
    btnSeat: 5
  }
};

let loggerSelectedHandId = null;


function saveLogger(){
  try{ localStorage.setItem(LS_LOGGER, JSON.stringify(loggerState)); }catch(e){}
}

function loadLogger(){
  try{
    const raw = localStorage.getItem(LS_LOGGER);
    if(!raw) return;

    const obj = JSON.parse(raw);
    if(!obj) return;

    // sessions + active id
    if(Array.isArray(obj.sessions)) loggerState.sessions = obj.sessions;
    if(("activeSessionId" in obj)) loggerState.activeSessionId = obj.activeSessionId;

    // table settings (merge defaults)
    if(obj.table && typeof obj.table === "object"){
      loggerState.table.maxPlayers = Number(obj.table.maxPlayers ?? loggerState.table.maxPlayers);
      loggerState.table.heroSeat   = Number(obj.table.heroSeat   ?? loggerState.table.heroSeat);
      loggerState.table.btnSeat    = Number(obj.table.btnSeat    ?? loggerState.table.btnSeat);
    }
  }catch(e){}
}


function uid(){
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

function getActiveSession(){
  return loggerState.sessions.find(s => s.id === loggerState.activeSessionId) || null;
}

// ===== Hand Logger: Table UI (v0) =====
function seatAngleDeg(i, n){
  // Seat 0 is Hero at 6 o’clock (bottom). Then CLOCKWISE.
  return 90 - (360 / n) * i;
}



function prevClockwiseSeat(i, n){
  // Renderer increases clockwise, so clockwise is +1
  return (i + 1) % n;
}

function nextCounterClockwiseSeat(i, n){
  // Renderer increases clockwise, so counter-clockwise is -1
  return (i - 1 + n) % n;
}


function buildSeatPositionsFromButton(btnSeat, n){
  // Starting at BTN and moving counter-clockwise around the table (UI "leftward"):
  // BTN, SB, BB, UTG, UTG+1, LJ, HJ, CO  (8-max)
  const posNames8 = ["BTN","SB","BB","UTG","UTG+1","LJ","HJ","CO"];

  const posBySeat = {};
  let seat = btnSeat;

  for(let k = 0; k < n; k++){
    posBySeat[seat] = posNames8[k] || `P${k+1}`;

    // Move counter-clockwise one seat.
    // IMPORTANT: With your current seat indexing/orientation, CCW is "-1".
    seat = (seat - 1 + n) % n;
  }

  return posBySeat;
}

// ===== Logger Card Picker (Hero + Board) =====
const LOGGER_RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];
const LOGGER_SUITS = [
  {key:"s", sym:"♠", cls:"pfBlack"},
  {key:"h", sym:"♥", cls:"pfRed"},
  {key:"d", sym:"♦", cls:"pfRed"},
  {key:"c", sym:"♣", cls:"pfBlack"}
];


let loggerCardPicker = {
  mode: null,              // "hero" or "board"
  handId: null,
  exclude: new Set(),
  slots: [],               // array of card strings or null
  activeIdx: 0,
  onSave: null
};

function isRedSuit(suitKey){ return suitKey === "h" || suitKey === "d"; }

function cardToPretty(card){
  if(!card) return "—";
  const r = card[0];
  const s = card[1];
  const suit = LOGGER_SUITS.find(x=>x.key===s);
  const sym = suit ? suit.sym : s;
  return r + sym;
}

function normalizeCard(card){
  if(!card) return null;
  const c = String(card).trim();
  if(c.length < 2) return null;
  const r = c[0].toUpperCase();
  const s = c[1].toLowerCase();
  if(!LOGGER_RANKS.includes(r)) return null;
  if(!["s","h","d","c"].includes(s)) return null;
  return r + s;
}

function allPickedCards(slots){
  return slots.filter(Boolean);
}

function renderLoggerCardSlots(){
  if(!loggerCardSlots) return;
  loggerCardSlots.innerHTML = "";

  loggerCardPicker.slots.forEach((card, idx)=>{
    const slot = document.createElement("div");
    slot.className = "pfCard" + (idx === loggerCardPicker.activeIdx ? " active" : "");

    const pretty = cardToPretty(card);

    const rank = document.createElement("div");
    rank.className = "pfRank";
    rank.textContent = pretty === "—" ? "—" : pretty[0];

    const suit = document.createElement("div");
    suit.className = "pfSuit " + (pretty === "—" ? "pfSuitBlk" : (isRedSuit(card[1]) ? "pfSuitRed" : "pfSuitBlk"));
    suit.textContent = pretty === "—" ? "" : pretty.slice(1);

    slot.appendChild(rank);
    slot.appendChild(suit);

    slot.addEventListener("click", ()=>{
      // clicking active slot clears it
      if(loggerCardPicker.activeIdx === idx){
        loggerCardPicker.slots[idx] = null;
        renderLoggerCardSlots();
        renderLoggerCardGrid();
        return;
      }
      loggerCardPicker.activeIdx = idx;
      renderLoggerCardSlots();
    });

    loggerCardSlots.appendChild(slot);
  });
}

function renderLoggerCardGrid(){
  if(!loggerCardGrid) return;
  loggerCardGrid.innerHTML = "";

  const picked = new Set(allPickedCards(loggerCardPicker.slots));
  const excluded = loggerCardPicker.exclude instanceof Set ? loggerCardPicker.exclude : new Set();


  LOGGER_SUITS.forEach(suit=>{
    const row = document.createElement("div");
    row.className = "pfSuitRow";

    const lab = document.createElement("div");
    lab.className = "pfSuitLabel " + suit.cls;
    lab.textContent = suit.sym;
    row.appendChild(lab);

    LOGGER_RANKS.forEach(r=>{
      const card = normalizeCard(r + suit.key);
      const isExcluded = excluded.has(card);
      const btn = document.createElement("div");
      btn.className = "pfCardBtn " + suit.cls;
      btn.textContent = r;

      const isAlreadyPicked = picked.has(card);
      if(isAlreadyPicked){
        btn.classList.add("selected");
      }

      if(isExcluded){
        btn.style.opacity = "0.25";
        btn.style.cursor = "not-allowed";
        btn.style.pointerEvents = "none";
        btn.title = "Card already in use";
      }


      btn.addEventListener("click", ()=>{
        // if this card is already in another slot, move it to active slot
        if(isExcluded) return;
        const existingIdx = loggerCardPicker.slots.findIndex(x=>x === card);
        if(existingIdx !== -1){
          loggerCardPicker.slots[existingIdx] = null;
        }
        loggerCardPicker.slots[loggerCardPicker.activeIdx] = card;

        // advance to next empty slot if possible
        const nextEmpty = loggerCardPicker.slots.findIndex((x, i)=>!x && i !== loggerCardPicker.activeIdx);
        if(nextEmpty !== -1) loggerCardPicker.activeIdx = nextEmpty;

        renderLoggerCardSlots();
        renderLoggerCardGrid();
      });

      row.appendChild(btn);
    });

    loggerCardGrid.appendChild(row);
  });
}

let loggerCardBackdrop, loggerCardModal, loggerCardTitle, loggerCardSub,
    loggerCardSlots, loggerCardGrid, loggerCardSave, loggerCardClose, loggerCardClearAll;

let loggerCardPickerBound = false;

function initLoggerCardPickerEls(){
  // grab elements (safe to call repeatedly)
  loggerCardBackdrop = document.getElementById("loggerCardBackdrop");
  loggerCardModal    = document.getElementById("loggerCardModal");
  loggerCardTitle    = document.getElementById("loggerCardTitle");
  loggerCardSub      = document.getElementById("loggerCardSub");
  loggerCardSlots    = document.getElementById("loggerCardSlots");
  loggerCardGrid     = document.getElementById("loggerCardGrid");
  loggerCardSave     = document.getElementById("loggerCardSave");
  loggerCardClose    = document.getElementById("loggerCardClose");
  loggerCardClearAll = document.getElementById("loggerCardClearAll");

  // bind listeners once
  if(loggerCardPickerBound) return;
  loggerCardPickerBound = true;

  if(loggerCardBackdrop){
    loggerCardBackdrop.addEventListener("click", ()=> closeLoggerCardPicker());
  }

  if(loggerCardModal){
    const panel = loggerCardModal.querySelector(".modalPanel");
    if(panel){
      panel.addEventListener("click", (e)=> e.stopPropagation());
    }
  }

  if(loggerCardClose){
    loggerCardClose.addEventListener("click", ()=> closeLoggerCardPicker());
  }

  if(loggerCardClearAll){
    loggerCardClearAll.addEventListener("click", ()=>{
      loggerCardPicker.slots = (loggerCardPicker.slots || []).map(()=> null);
      loggerCardPicker.activeIdx = 0;
      renderLoggerCardSlots();
      renderLoggerCardGrid();
    });
  }

  if(loggerCardSave){
    loggerCardSave.addEventListener("click", ()=>{
      if(typeof loggerCardPicker?.onSave === "function"){
        loggerCardPicker.onSave((loggerCardPicker.slots || []).slice());
      }
      closeLoggerCardPicker();
    });
  }
}




  
function openLoggerCardPicker({ title, sub, slots, onSave, exclude }){
  initLoggerCardPickerEls();

  loggerCardPicker.mode = title;
  loggerCardPicker.handId = null;

  loggerCardPicker.slots = (slots || []).map(c => c ? normalizeCard(c) : null);

  loggerCardPicker.activeIdx = Math.max(0, loggerCardPicker.slots.findIndex(x=>!x));
  if(loggerCardPicker.activeIdx === -1) loggerCardPicker.activeIdx = 0;

  loggerCardPicker.exclude = (exclude instanceof Set) ? exclude : new Set();

  loggerCardPicker.onSave = onSave;

  if(loggerCardTitle) loggerCardTitle.textContent = title;
  if(loggerCardSub) loggerCardSub.textContent = sub;

  renderLoggerCardSlots();
  renderLoggerCardGrid();

  if(loggerCardModal) loggerCardModal.style.display = "block";
}


function closeLoggerCardPicker(){
  if(loggerCardModal) loggerCardModal.style.display = "none";
  loggerCardPicker.onSave = null;
}

if(loggerCardBackdrop) loggerCardBackdrop.addEventListener("click", closeLoggerCardPicker);
if(loggerCardClose) loggerCardClose.addEventListener("click", closeLoggerCardPicker);

if(loggerCardClearAll){
  loggerCardClearAll.addEventListener("click", ()=>{
    loggerCardPicker.slots = loggerCardPicker.slots.map(()=>null);
    loggerCardPicker.activeIdx = 0;
    renderLoggerCardSlots();
    renderLoggerCardGrid();
  });
}

if(loggerCardSave){
  loggerCardSave.addEventListener("click", ()=>{
    if(typeof loggerCardPicker.onSave === "function"){
      loggerCardPicker.onSave(loggerCardPicker.slots.slice());
    }
    closeLoggerCardPicker();
  });
}



function renderLoggerTable(){
  const mount = document.getElementById("loggerTableMount");
  if(!mount) return;

  const n = Number(loggerState?.table?.maxPlayers || 8);

  // Hard lock: hero always bottom (seat index 0)
  loggerState.table.heroSeat = 0;

  const heroSeat = 0;
  const btnSeat = Number(loggerState?.table?.btnSeat ?? 5);

  const posBySeat = buildSeatPositionsFromButton(btnSeat, n);

  mount.innerHTML = "";

  const wrap = document.createElement("div");
  wrap.className = "loggerTableWrap";

  // Controls row (only Set Button)
  const controls = document.createElement("div");
  controls.className = "loggerTableControls";

  const btnBtn = document.createElement("button");
  btnBtn.textContent = "Set Button";
  btnBtn.className = "pfPrimary";

  const modePill = document.createElement("div");
  modePill.className = "loggerModePill on";
  modePill.textContent = "Click a seat to set BUTTON (Hero is always bottom)";

  controls.appendChild(btnBtn);
  controls.appendChild(modePill);

  // Table
  const table = document.createElement("div");
  table.className = "loggerTable";

  const cx = 50, cy = 50;
  const r = 42;

  for(let i = 0; i < n; i++){
    const ang = seatAngleDeg(i, n) * Math.PI / 180;
    const x = cx + r * Math.cos(ang);
    const y = cy + r * Math.sin(ang);

    const seat = document.createElement("div");
    seat.className = "loggerSeat";
    seat.style.left = x + "%";
    seat.style.top  = y + "%";
    seat.style.transform = "translate(-50%, -50%)";

    if(i === heroSeat) seat.classList.add("hero");
    if(i === btnSeat)  seat.classList.add("btn");

    const lbl = document.createElement("div");
    lbl.className = "lbl";
    lbl.textContent = posBySeat[i] || `Seat ${i+1}`;
    seat.appendChild(lbl);

    if(i === heroSeat){
      const t = document.createElement("span");
      t.className = "tag";
      t.textContent = "HERO";
      seat.appendChild(t);
    }

    if(i === btnSeat){
      const t = document.createElement("span");
      t.className = "tag";
      t.textContent = "BTN";
      seat.appendChild(t);
    }

// Highlight selected actor seat in ACTOR mode
const mode = loggerState?.table?.uiMode || "BTN";
const active = getActiveSession ? getActiveSession() : null;
const curHand = (active && loggerSelectedHandId)
  ? (active.hands || []).find(h => h.id === loggerSelectedHandId)
  : null;

const started = !!(curHand && ((curHand.heroCards||[]).filter(Boolean).length === 2));
const locked = !!(curHand && (curHand.btnLocked || started));

// Until the hand starts (hero cards selected), default to BTN mode
const effectiveMode = locked ? "ACTOR" : (started ? mode : "BTN");


if(effectiveMode === "ACTOR"){
  const nPlayers = Number(loggerState?.table?.maxPlayers || 8);
  const btnSeatLocal = Number((curHand && curHand.btnSeat != null) ? curHand.btnSeat : loggerState?.table?.btnSeat || 0);
  const posBySeat = buildSeatPositionsFromButton(btnSeatLocal, nPlayers);
  const pos = posBySeat[i] || `P${i+1}`;

  if(loggerState?.table?.selectedActorPos && pos === loggerState.table.selectedActorPos){
    seat.style.outline = "2px solid rgba(255,215,0,.75)";
    seat.style.boxShadow = "0 0 0 3px rgba(255,215,0,.12)";
  }
}

    
seat.addEventListener("click", ()=>{
  const active = getActiveSession ? getActiveSession() : null;
  const curHand = (active && loggerSelectedHandId)
    ? (active.hands || []).find(h => h.id === loggerSelectedHandId)
    : null;

  const locked = !!(curHand && (curHand.btnLocked || ((curHand.heroCards||[]).filter(Boolean).length === 2)));
  const mode = loggerState?.table?.uiMode || "BTN";

  // Build positions for mapping seat -> position
  const nPlayers = Number(loggerState?.table?.maxPlayers || 8);
  const btnSeatLocal = Number((curHand && curHand.btnSeat != null) ? curHand.btnSeat : loggerState?.table?.btnSeat || 0);
  const posBySeat = buildSeatPositionsFromButton(btnSeatLocal, nPlayers);

  // If locked, force ACTOR mode
  const effectiveMode = locked ? "ACTOR" : mode;

  if(effectiveMode === "BTN"){
    // Set BTN seat (only allowed before hand starts)
    loggerState.table.btnSeat = i;

    // If editing a hand, keep it consistent
    if(curHand){
      curHand.btnSeat = i;
      // If user changes BTN mid-hand (rare), positions change—clear actor selection
      loggerState.table.selectedActorPos = null;
    }

    saveLogger();
    renderLoggerTable();
    renderLoggerSessionSummary?.();
    renderLoggerHandEditor?.(curHand || null);
    toast("Button set");
    return;
  }

  // ACTOR mode: click seat selects acting player
  const pos = posBySeat[i] || `P${i+1}`;
  loggerState.table.selectedActorPos = pos;

  saveLogger();
  renderLoggerTable();
  renderLoggerHandEditor?.(curHand || null);
  toast(`Actor: ${pos}`);
});


    table.appendChild(seat);
  }

  const legend = document.createElement("div");
  legend.className = "loggerTableLegend";
  legend.innerHTML =
    `<span><span class="loggerLegendDot hero"></span> Hero</span>` +
    `<span><span class="loggerLegendDot btn"></span> Button</span>` +
    `<span>• Positions auto-populate from Button</span>`;

  wrap.appendChild(controls);
  wrap.appendChild(table);
  wrap.appendChild(legend);

  mount.appendChild(wrap);
}
// ===== /Hand Logger: Table UI (v0) =====




  function loadSession(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(typeof obj?.correct === "number") session.correct = obj.correct;
      if(typeof obj?.total === "number") session.total = obj.total;
      if(typeof obj?.streak === "number") session.streak = obj.streak;
      if(Array.isArray(obj?.missed)) session.missed = obj.missed;
    } catch(e){ /* ignore */ }
  }

  function saveSession(){
    try{
      localStorage.setItem(LS_KEY, JSON.stringify(session));
    } catch(e){ /* ignore */ }
  }

  function loadPersona(){
  try{
    const p = localStorage.getItem(LS_PERSONA);
    if(p && personaSel) personaSel.value = p;
  }catch(e){}
}

function savePersona(){
  try{
    if(personaSel) localStorage.setItem(LS_PERSONA, personaSel.value);
  }catch(e){}
}



  
  function renderStats(){
    stCorrect.textContent = session.correct;
    stTotal.textContent = session.total;
    const acc = session.total ? (session.correct/session.total*100).toFixed(1) : "0.0";
    stAcc.textContent = `${acc}%`;
    stStreak.textContent = session.streak;
    stMissed.textContent = session.missed.length ? session.missed.slice(0, 10).join(" • ") : "—";
  }

  function randomChoice(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function chooseScenarioKey(){
    const v = trainerScenarioSel.value;
    if(v && v !== "__RANDOM__") return v;
    const keys = Object.keys(scenarios);
    return randomChoice(keys);
  }

 function listHands(map, mode){
  const all = Object.keys(map);

  const codeOf = (h) => handCodeFromMapVal(map[h]);

  if(mode === "all") return all;

  if(mode === "playable"){
    return all.filter(h => codeOf(h) !== "F");
  }

  if(mode === "edge"){
    const missedHands = session.missed
      .map(x => x.split(": ")[1]?.split(" ")[0])
      .filter(Boolean);

    const uniq = [...new Set(missedHands)].filter(h => map[h]);
    return uniq.length ? uniq : all.filter(h => codeOf(h) !== "F");
  }

  if(mode === "smart"){
    const playable = all.filter(h => codeOf(h) !== "F");
    const folds    = all.filter(h => codeOf(h) === "F");

    const foldCount = Math.min(
      Math.floor(playable.length * 0.45),
      Math.floor(folds.length * 0.35)
    );

    const foldSubset = [];
    for(let i=0;i<foldCount;i++) foldSubset.push(randomChoice(folds));

    const weighted = [];
    for(const h of playable){
      const a = codeOf(h);
      let w = 1;
      if(a === "M") w = 3;
      else if(a === "C" || a === "R") w = 2;
      for(let k=0;k<w;k++) weighted.push(h);
    }

    for(const h of foldSubset) weighted.push(h);

    const missedHands = session.missed
      .map(x => x.split(": ")[1]?.split(" ")[0])
      .filter(Boolean);

    const uniqMissed = [...new Set(missedHands)].filter(h => map[h]);
    for(const h of uniqMissed){
      for(let k=0;k<6;k++) weighted.push(h);
    }

    return weighted.length ? weighted : all;
  }

  return all;
}


  let current = { scenarioKey: null, hand: null, correct: null, prettyHand: null };

  function setButtonsEnabled(enabled){
    [btnRaise, btnCall, btnFold].forEach(b => b.disabled = !enabled);
  }

 function prettyHandFromCode(code){
  return canonicalHand(code);
}


  function scenarioLabel(key){
    return scenarios[key]?.name || key;
  }

 function noteForTrainer(key, handCode, correctAct){
  const { notes, mixWeights } = getScenarioData(key);

  if(notes && notes[handCode]) return notes[handCode];

  // A little more contextual messaging
  if(correctAct === "F") return "Fold: dominated / poor equity realization / rake-sensitive in this spot.";
  if(correctAct === "C") return "Call: defend with playable equity; avoid turning everything into a bloated rake pot.";
  if(correctAct === "R"){
    if(key.includes("RFI")) return "Raise first in: take initiative and capture dead money from antes.";
    return "Raise: value/pressure (linear, rake-aware).";
  }
  if(correctAct === "M"){
    const w = mixWeights?.[handCode] || { R: 0.5, C: 0.5 };
    return `Mix: both actions are OK here. Frequency guidance: ${mixText(w)} (preferred: ${mixPreferred(w)}).`;
  }

  return "—";
}

function mixPctLabelFromDist(d){
  const parts = [
    ["R", Math.round((d.R || 0) * 100)],
    ["C", Math.round((d.C || 0) * 100)],
    ["F", Math.round((d.F || 0) * 100)],
  ]
    .filter(([,p]) => p > 0)
    .sort((a,b) => b[1] - a[1]);

  // show the top two weights to keep it compact (e.g. "88F/12R")
  return parts.slice(0, 2).map(([k,p]) => `${p}${k}`).join("/");
}

  
  function renderMiniMatrix(key, selectedHand, selStatus){
    if(!trainerMatrix) return;
   const { map, mixWeights } = getScenarioData(key);


    trainerMatrix.innerHTML = "";
    // header row
    trainerMatrix.appendChild(hdrCorner());
    ranks.forEach(r=> trainerMatrix.appendChild(hdr(r)));

    for(const rRow of ranks){
      trainerMatrix.appendChild(hdr(rRow));
      for(const rCol of ranks){
        const h = handForCell(rRow, rCol);
const aRaw = map[h] ?? "F";

// Normalize to a distribution first
const d = (typeof aRaw === "string")
  ? actionToDist(h, aRaw, mixWeights)
  : normalizeDist(aRaw || dist("F", 1));

// Label can still show M/R/C/F if you want
const a = distToCode(d);

// Border/color should use dominant action
const prim = primaryAction(d);
const meta = ACT[prim] || ACT.F;

const el = document.createElement("div");
el.className = `cell ${meta.cls}`;

// Set proportional overlay variables (0..100)
el.style.setProperty("--r", (d.R * 100).toFixed(0));
el.style.setProperty("--c", (d.C * 100).toFixed(0));
el.style.setProperty("--f", (d.F * 100).toFixed(0));
if(isMix(d)) el.classList.add("isMixed");

el.dataset.hand = h;
const handLabel = displayHandLabel(rRow, rCol);
const w = (a === "M") ? (mixWeights?.[h] || { R: 0.5, C: 0.5 }) : null;


if(a === "M"){
  el.style.setProperty("--mixA", mixIntensity(w));
}

const mixBadge = "";

el.innerHTML =
  `<div class="hand">${handLabel}</div>` +
   "" +
  mixBadge;

        if(selectedHand && h === selectedHand){
          el.classList.add("sel");
          if(selStatus === "good") el.classList.add("good");
          if(selStatus === "bad") el.classList.add("bad");
        }
        // allow click to peek in trainer
        el.addEventListener("click", ()=>{
          toast(`${handLabel}: ${prettyAction(a)}`);
        });
        trainerMatrix.appendChild(el);
      }
    }
  }

  function startQuestion(){
    const key = chooseScenarioKey();
    const { map } = getScenarioData(key);
    const mode = trainerRandomness.value;
    const hands = listHands(map, mode);
    const hand = randomChoice(hands);
   const actRaw = map[hand] ?? "F";
const actCode = (typeof actRaw === "string") ? actRaw : distToCode(actRaw);

current = {
  scenarioKey: key,
  hand,
  correct: actCode,     // always R/C/F/M now
  correctRaw: actRaw,   // optional: keeps the original for debugging
  prettyHand: prettyHandFromCode(hand)
};

    trainerPrompt.textContent = `${scenarioLabel(key)} — What do you do with:`;
    trainerHandEl.textContent = current.prettyHand;

    trainerResult.style.display = "none";
    trainerBadge.className = "trainerBadge";
    trainerBadge.textContent = "";

    // Hide reference grid until after the answer
    if(trainerRef) trainerRef.style.display = "none";
    if(trainerMatrix) trainerMatrix.innerHTML = "";

    setButtonsEnabled(true);
  }

function isCorrect(userAct, correctAct, correctRaw){
  // If correctRaw is a distribution, accept any action that has weight > 0
  if(correctRaw && typeof correctRaw === "object"){
    const d = normalizeDist(correctRaw);
    const eps = 1e-9;
    if(userAct === "R") return d.R > eps;
    if(userAct === "C") return d.C > eps;
    if(userAct === "F") return d.F > eps;
    return false;
  }

  // Fallback: if correctAct is a code
  if(correctAct === "M"){
    // legacy behavior (Raise or Call)
    return userAct === "R" || userAct === "C";
  }
  return userAct === correctAct;
}


  function submit(userAct){
    const key = current.scenarioKey;
    const hand = current.hand;
    const correctAct = current.correct;

    session.total += 1;

const ok = isCorrect(userAct, correctAct, current.correctRaw);

    if(ok){
      session.correct += 1;
      session.streak += 1;
    } else {
      session.streak = 0;
      const miss = `${scenarioLabel(key)}: ${hand} (correct ${prettyAction(correctAct)})`;

      session.missed.unshift(miss);
      session.missed = session.missed.slice(0, 30);
    }

    saveSession();
    renderStats();

    setButtonsEnabled(false);
    trainerResult.style.display = "block";

    if(trainerChoiceLine){
  trainerChoiceLine.textContent = `You chose: ${prettyAction(userAct)} • Correct: ${prettyAction(correctAct)}`;
}

if(trainerPersonaLine){
  trainerPersonaLine.textContent = buildTrainerPersonaDeltaText(hand, key);
}



    if(ok){
      trainerResultTitle.textContent = "Correct";
      trainerBadge.textContent = "NICE";
      trainerBadge.classList.add("good");
    } else {
      trainerResultTitle.textContent = "Not quite";
      trainerBadge.textContent = `Correct: ${prettyAction(correctAct)}`;
      trainerBadge.classList.add("bad");
    }

    // Explain
    const n = noteForTrainer(key, hand, correctAct);
    if(correctAct === "M"){
      trainerBadge.textContent = "Mix (Raise or Call)";
      trainerBadge.className = "trainerBadge mix";
      trainerExplain.textContent = `${n} (In this trainer, Raise OR Call counts as correct.)`;
    } else {
      trainerExplain.textContent = n;
    }

    // Visual: show reference grid only after answer + highlight selected hand
    if(trainerRef) trainerRef.style.display = "block";
    renderMiniMatrix(key, hand, ok ? "good" : "bad");
  }

const loggerView  = document.getElementById("loggerView");
const loggerBtn   = document.getElementById("loggerBtn");
const loggerNewSessionBtn = document.getElementById("loggerNewSession");
const loggerSessionSel    = document.getElementById("loggerSessionSel");
const loggerSessionSummary= document.getElementById("loggerSessionSummary");
const loggerSessionSettings = document.getElementById("loggerSessionSettings");


function refreshLoggerUI(){
  renderLoggerSessionSummary();
  renderLoggerSessionSettings();   // <-- ADD
  renderLoggerHandsList();
  renderLoggerHandEditor(null);
}



function renderLoggerSessions(){
  if(!loggerSessionSel) return;

  loggerSessionSel.innerHTML = "";

  if(!loggerState.sessions.length){
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "No sessions";
    loggerSessionSel.appendChild(opt);
    if(loggerSessionSummary) loggerSessionSummary.textContent = "No session selected.";
    return;
  }

  for(const s of loggerState.sessions){
    const opt = document.createElement("option");
    opt.value = s.id;
    const dt = new Date(s.createdAt || Date.now());
    opt.textContent = `${dt.toLocaleDateString()} ${dt.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}`;
    loggerSessionSel.appendChild(opt);
  }

  const nextId = loggerState.activeSessionId || loggerState.sessions[0].id;
  loggerSessionSel.value = nextId;
  loggerState.activeSessionId = nextId;
}


function createLoggerSession(){
  const s = {
    id: uid(),
    createdAt: Date.now(),
    stakes: "$0.05/$0.10",
    ante: "$0.05",
    straddle: false,
    maxPlayers: 8,
    hands: [],
  };
  loggerState.sessions.unshift(s);
  loggerState.activeSessionId = s.id;
  if(!loggerState.table) loggerState.table = {};
  loggerState.table.maxPlayers = s.maxPlayers;

saveLogger();
renderLoggerSessions();
refreshLoggerUI();
renderLoggerTable();
toast("New session created");
}

function parseStakes(stakesStr){
  // Accepts strings like "$0.05/$0.10", "0.05/0.10", "€0.5/1"
  const s = String(stakesStr || "").trim();

  // Grab leading currency symbol if present
  const curMatch = s.match(/^[^\d\s]+/);
  const currency = curMatch ? curMatch[0] : "$";

  // Extract the first two numbers
  const nums = s.match(/(\d+(\.\d+)?)/g) || [];
  const sb = nums.length >= 1 ? Number(nums[0]) : 0;
  const bb = nums.length >= 2 ? Number(nums[1]) : 0;

  return { currency, sb, bb };
}

function fmtMoney(currency, amt){
  const n = Number(amt || 0);
  if(!isFinite(n)) return `${currency}0`;
  // Keep it simple; you can refine later
  return `${currency}${n.toFixed(n < 1 ? 2 : 0)}`;
}

function uidShort(){
  return Math.random().toString(16).slice(2, 8);
}

function getActiveSessionMeta(){
  const active = getActiveSession();
  const parsed = active ? parseStakes(active.stakes) : { currency: "$", sb: 0, bb: 0 };
  const anteParsed = active ? parseStakes(active.ante || "").currency : parsed.currency;
  return {
    currency: parsed.currency || "$",
    sb: Number(parsed.sb || 0),
    bb: Number(parsed.bb || 0),
    ante: active?.ante || "",
    straddle: !!active?.straddle,
    maxPlayers: Number(active?.maxPlayers || 8)
  };
}

function bbToMoney(bb, bbSize){
  const n = Number(bb || 0);
  const b = Number(bbSize || 0);
  if(!isFinite(n) || !isFinite(b)) return 0;
  return n * b;
}

function moneyToBb(money, bbSize){
  const n = Number(money || 0);
  const b = Number(bbSize || 0);
  if(!isFinite(n) || !isFinite(b) || b === 0) return 0;
  return n / b;
}

function ensureHandActions(hand){
  if(!hand.actions) hand.actions = [];
  return hand.actions;
}

function fmtActionLine(meta, a){
  const act = String(a.action || "").toUpperCase();
  const who = a.actorPos || "";

  let amt = "";
  if(a.amt && a.amt !== 0){
    if(a.unit === "MONEY"){
      amt = " " + fmtMoney(meta.currency, a.amt);
    } else {
      amt = " " + String(a.amt) + "bb";
    }
  }

  // Our semantics: RAISE/CALL are "to X"
  if((act === "RAISE" || act === "CALL") && amt){
    amt = " to" + amt;
  }

  return `${who} ${act}${amt}`.trim();
}

function renderBoardSummaryInto(el, hand, mode){
  if(!el) return;

  const flop = (hand.board && Array.isArray(hand.board.flop)) ? hand.board.flop : [null,null,null];
  const turn = hand.board ? hand.board.turn : null;
  const river = hand.board ? hand.board.river : null;

  function cardTxt(c){
    if(!c) return "—";
    if(typeof c === "string") return c;
    // common shapes
    if(c.r && c.suit) return String(c.r) + String(c.suit);
    if(c.rank && c.suit) return String(c.rank) + String(c.suit);
    if(c.r && c.s) return String(c.r) + String(c.s);
    if(c.rank && c.s) return String(c.rank) + String(c.s);
    return "—";
  }

  let showFlop = false, showTurn = false, showRiver = false;

  if(mode === "REVIEW"){
    const st = getReplayStreet(hand);
    showFlop = (st === "FLOP" || st === "TURN" || st === "RIVER");
    showTurn = (st === "TURN" || st === "RIVER");
    showRiver = (st === "RIVER");
  } else {
    // LOG mode: always show full board as currently set
    showFlop = true;
    showTurn = true;
    showRiver = true;
  }

  const f1 = showFlop ? cardTxt(flop[0]) : "—";
  const f2 = showFlop ? cardTxt(flop[1]) : "—";
  const f3 = showFlop ? cardTxt(flop[2]) : "—";
  const t  = showTurn ? cardTxt(turn) : "—";
  const r  = showRiver ? cardTxt(river) : "—";

  el.textContent = `${f1} ${f2} ${f3}  |  ${t}  |  ${r}`;
}


function getSortedActions(hand){
  return ensureHandActions(hand)
    .slice()
    .sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));
}

function getReplayStreet(hand){
  const actions = getSortedActions(hand);
  if(!actions.length) return "PREFLOP";

  let idx = Number(hand.replayIdx || 0);
  if(!isFinite(idx) || idx < 0) idx = 0;
  if(idx > actions.length - 1) idx = actions.length - 1;

  const st = String(actions[idx].street || "").toUpperCase();
  if(st === "FLOP" || st === "TURN" || st === "RIVER") return st;
  return "PREFLOP";
}



function isHandStarted(hand){
  if(!hand) return false;
  const hc = hand.heroCards || [];
  return Boolean(hc[0] && hc[1]);
}


  
function renderLoggerSessionSummary(){
  const active = getActiveSession();
  if(!loggerSessionSummary) return;

  if(!active){
    loggerSessionSummary.textContent = "No session selected.";
    return;
  }

  const created = new Date(active.createdAt || Date.now()).toLocaleString();
  const handsCount = (active.hands || []).length;
  const btnSeat = Number(loggerState?.table?.btnSeat ?? 0);
  
  loggerSessionSummary.textContent =
    `Active session created ${created} • Hands: ${handsCount} • Button seat: ${Number(loggerState.table.btnSeat) + 1}`;
}

function renderLoggerSessionSettings(){
  if(!loggerSessionSettings) return;

  const active = getActiveSession();
  if(!active){
    loggerSessionSettings.innerHTML = "";
    return;
  }

  // Defaults (in case older sessions exist)
  if(active.stakes == null) active.stakes = "$0.05/$0.10";
  if(active.ante == null) active.ante = "$0.00";
  if(active.straddle == null) active.straddle = false;
  if(active.maxPlayers == null) active.maxPlayers = 8;

  const parsed = parseStakes(active.stakes);
  const bbAmt = parsed.bb || 0;

  loggerSessionSettings.innerHTML = "";

  const wrap = document.createElement("div");
  wrap.style.display = "grid";
  wrap.style.gap = "10px";
  wrap.style.paddingTop = "6px";

  const title = document.createElement("div");
  title.className = "kicker";
  title.style.color = "var(--muted)";
  title.style.fontWeight = "800";
  title.textContent = "Session settings";

  const grid = document.createElement("div");
  grid.style.display = "grid";
  grid.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
  grid.style.gap = "10px";

  // Stakes
  const stakesBox = document.createElement("div");
  const stakesLabel = document.createElement("div");
  stakesLabel.className = "kicker";
  stakesLabel.textContent = "Stakes (SB/BB)";
  const stakesInput = document.createElement("input");
  stakesInput.type = "text";
  stakesInput.value = active.stakes || "";
  stakesInput.placeholder = "$0.05/$0.10";
  stakesInput.style.width = "100%";
  stakesInput.style.borderRadius = "12px";
  stakesInput.style.border = "1px solid rgba(255,255,255,.10)";
  stakesInput.style.background = "rgba(0,0,0,.18)";
  stakesInput.style.color = "var(--text)";
  stakesInput.style.padding = "10px 12px";
  stakesInput.style.fontWeight = "800";

  stakesInput.addEventListener("change", ()=>{
    active.stakes = stakesInput.value.trim();
    saveLogger();
    renderLoggerSessionSummary();
    renderLoggerSessionSettings(); // refresh derived BB display
  });

  stakesBox.appendChild(stakesLabel);
  stakesBox.appendChild(stakesInput);

  // Ante
  const anteBox = document.createElement("div");
  const anteLabel = document.createElement("div");
  anteLabel.className = "kicker";
  anteLabel.textContent = "Ante";
  const anteInput = document.createElement("input");
  anteInput.type = "text";
  anteInput.value = active.ante || "";
  anteInput.placeholder = "$0.00";
  anteInput.style.width = "100%";
  anteInput.style.borderRadius = "12px";
  anteInput.style.border = "1px solid rgba(255,255,255,.10)";
  anteInput.style.background = "rgba(0,0,0,.18)";
  anteInput.style.color = "var(--text)";
  anteInput.style.padding = "10px 12px";
  anteInput.style.fontWeight = "800";

  anteInput.addEventListener("change", ()=>{
    active.ante = anteInput.value.trim();
    saveLogger();
    renderLoggerSessionSummary();
  });

  anteBox.appendChild(anteLabel);
  anteBox.appendChild(anteInput);

  // Straddle
  const straddleBox = document.createElement("div");
  straddleBox.style.display = "flex";
  straddleBox.style.alignItems = "center";
  straddleBox.style.gap = "10px";
  straddleBox.style.paddingTop = "18px";

  const straddleInput = document.createElement("input");
  straddleInput.type = "checkbox";
  straddleInput.checked = !!active.straddle;

  const straddleLabel = document.createElement("div");
  straddleLabel.className = "kicker";
  straddleLabel.textContent = "Straddle on";

  straddleInput.addEventListener("change", ()=>{
    active.straddle = !!straddleInput.checked;
    saveLogger();
    renderLoggerSessionSummary();
  });

  straddleBox.appendChild(straddleInput);
  straddleBox.appendChild(straddleLabel);

  // Max Players
  const maxBox = document.createElement("div");
  const maxLabel = document.createElement("div");
  maxLabel.className = "kicker";
  maxLabel.textContent = "Max players";
  const maxSel = document.createElement("select");
  maxSel.style.width = "100%";
  maxSel.style.borderRadius = "12px";
  maxSel.style.border = "1px solid rgba(255,255,255,.10)";
  maxSel.style.background = "rgba(0,0,0,.18)";
  maxSel.style.color = "var(--text)";
  maxSel.style.padding = "10px 12px";
  maxSel.style.fontWeight = "800";

  for(let n=2; n<=10; n++){
    const opt = document.createElement("option");
    opt.value = String(n);
    opt.textContent = String(n);
    maxSel.appendChild(opt);
  }
  maxSel.value = String(Number(active.maxPlayers || 8));

  maxSel.addEventListener("change", ()=>{
    const next = Number(maxSel.value);
    active.maxPlayers = next;

    // Keep the table UI in sync (since you use loggerState.table.maxPlayers elsewhere)
    if(!loggerState.table) loggerState.table = {};
    loggerState.table.maxPlayers = next;

    saveLogger();
    renderLoggerSessionSummary();
    renderLoggerTable();      // re-layout seats
    renderLoggerHandsList();  // hands show updated "Players: n" in editor/meta
  });

  maxBox.appendChild(maxLabel);
  maxBox.appendChild(maxSel);

  grid.appendChild(stakesBox);
  grid.appendChild(anteBox);
  grid.appendChild(straddleBox);
  grid.appendChild(maxBox);

  // Derived line (BB)
  const derived = document.createElement("div");
  derived.className = "kicker";
  derived.style.color = "var(--muted)";
  derived.style.fontWeight = "750";
  derived.textContent = bbAmt
    ? `Derived BB = ${fmtMoney(parsed.currency, bbAmt)} (used for BB-based bet entry later)`
    : `Derived BB = — (enter stakes like $0.05/$0.10)`;

  wrap.appendChild(title);
  wrap.appendChild(grid);
  wrap.appendChild(derived);

  loggerSessionSettings.appendChild(wrap);
}

  
function renderLoggerHandsList(){
  const el = document.getElementById("loggerHandsList");
  if(!el) return;

  const active = getActiveSession();
  if(!active){
    el.textContent = "—";
    return;
  }

  const hands = active.hands || [];
  if(!hands.length){
    el.textContent = "No hands yet. Click “Log new hand”.";
    return;
  }

  el.innerHTML = "";
  el.style.display = "flex";
  el.style.flexDirection = "column";
  el.style.gap = "6px";

  hands.forEach((h, idx)=>{
    const row = document.createElement("div");
    row.style.padding = "6px 8px";
    row.style.borderRadius = "8px";
    row.style.cursor = "pointer";
    row.style.fontWeight = "800";
    row.style.whiteSpace = "nowrap";
    row.style.overflow = "hidden";
    row.style.textOverflow = "ellipsis";
    row.style.background = (h.id === loggerSelectedHandId) ? "rgba(255,255,255,.08)" : "transparent";

    const dt = new Date(h.createdAt || Date.now()).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    const label = idx === 0 ? "Most recent" : `Hand ${idx + 1}`;

row.style.display = "flex";
row.style.alignItems = "center";
row.style.justifyContent = "space-between";
row.style.gap = "10px";

const left = document.createElement("span");
left.textContent = label;
left.style.minWidth = "0";
left.style.overflow = "hidden";
left.style.textOverflow = "ellipsis";
left.style.whiteSpace = "nowrap";

const right = document.createElement("span");
right.textContent = `${dt} • BTN ${Number(h.btnSeat) + 1}`;
right.style.whiteSpace = "nowrap";
right.style.opacity = "0.95";
right.style.fontWeight = "800";

row.appendChild(left);
row.appendChild(right);



    row.addEventListener("click", ()=>{
      loggerSelectedHandId = h.id;
      renderLoggerHandsList();
      renderLoggerHandEditor(h);
    });

    el.appendChild(row);
  });
}


function renderLoggerHandEditor(hand){
  const mount = document.getElementById("loggerHandEditor");
  if(!mount) return;

  const active = getActiveSession();
  if(!active){
    mount.textContent = "Select a session and click “Log new hand”.";
    return;
  }

  if(!hand){
    mount.textContent = "Click “Log new hand” to begin.";
    return;
  }

  const n = Number(loggerState?.table?.maxPlayers || 8);
  const posBySeat = buildSeatPositionsFromButton(Number(hand.btnSeat), n);
  const heroPos = posBySeat[0] || "HERO";
  const started = isHandStarted(hand);

  mount.innerHTML = "";

    // ===== Hand gating: require hero cards to start =====
  if(!started){
    const gate = document.createElement("div");
    gate.style.display = "grid";
    gate.style.gap = "10px";
    gate.style.padding = "12px 14px";
    gate.style.borderRadius = "16px";
    gate.style.border = "1px solid rgba(255,255,255,.10)";
    gate.style.background = "rgba(255,255,255,.03)";

    const t = document.createElement("div");
    t.style.fontWeight = "950";
    t.textContent = "Start this hand";

    const d = document.createElement("div");
    d.className = "kicker";
    d.style.color = "var(--muted)";
    d.textContent = "Pick hero cards first. Actions and board will unlock after that.";

    const btn = document.createElement("button");
    btn.textContent = "Pick hero cards";
    btn.style.width = "fit-content";
    btn.style.padding = "10px 14px";
    btn.style.borderRadius = "12px";
    btn.style.fontWeight = "900";

    btn.addEventListener("click", ()=>{
      openLoggerCardPicker({
        title: "Pick hero cards",
        sub: "Select exactly 2 cards.",
        slots: (hand.heroCards || [null,null]).slice(),
        exclude: new Set([
          ...(hand.board?.flop || []),
          hand.board?.turn || null,
          hand.board?.river || null
        ].filter(Boolean)),
      onSave: (newSlots)=>{
  hand.heroCards = [newSlots[0] || null, newSlots[1] || null];

  const hasHero2 = !!hand.heroCards[0] && !!hand.heroCards[1];
  if(hasHero2){
    hand.btnLocked = true;
    if(loggerState && loggerState.table){
      loggerState.table.uiMode = "ACTOR";
    }
  }

  saveLogger();
  renderLoggerTable();
  renderLoggerHandEditor(hand);
  renderLoggerHandsList();
}

      });
    });

    gate.appendChild(t);
    gate.appendChild(d);
    gate.appendChild(btn);

    mount.appendChild(gate);

    // Still show notes at least (optional) OR exit entirely.
    // For now, exit early so the screen is clean.
    return;
  }
  // ===== /Hand gating =====


  const top = document.createElement("div");
  top.style.display = "grid";
  top.style.gap = "10px";

  const title = document.createElement("div");
  title.style.fontWeight = "950";
  title.textContent = `Editing hand • Hero position: ${heroPos}`;

  const meta = document.createElement("div");
  meta.className = "kicker";
  meta.style.color = "var(--muted)";
  meta.textContent = `BTN seat: ${Number(hand.btnSeat) + 1} • Hero seat: 1 • Players: ${n}`;

  const notesLabel = document.createElement("div");
  notesLabel.className = "kicker";
  notesLabel.textContent = "Notes (optional)";

  const heroLine = document.createElement("div");
heroLine.style.display = "flex";
heroLine.style.gap = "10px";
heroLine.style.flexWrap = "wrap";
heroLine.style.alignItems = "center";

const heroLabel = document.createElement("div");
heroLabel.style.fontWeight = "950";
heroLabel.textContent = "Hero cards";

const heroVal = document.createElement("div");
heroVal.className = "kicker";
heroVal.style.fontWeight = "900";
heroVal.textContent = hand.heroCards && hand.heroCards.length === 2
  ? `${cardToPretty(hand.heroCards[0])} ${cardToPretty(hand.heroCards[1])}`
  : "—";

const heroBtn = document.createElement("button");
heroBtn.textContent = "Pick hero cards";
heroBtn.addEventListener("click", ()=>{
  const slots = (hand.heroCards && hand.heroCards.length === 2) ? hand.heroCards.slice() : [null,null];
  openLoggerCardPicker({
    title: "Pick hero cards",
    sub: "Select exactly 2 cards.",
    slots,
    exclude: new Set([
    ...(hand.board?.flop || []),
    hand.board?.turn || null,
    hand.board?.river || null
    ].filter(Boolean)),

onSave: (newSlots)=>{
  hand.heroCards = [newSlots[0] || null, newSlots[1] || null];

  // Lock BTN once hero cards are set (start-of-hand trigger)
  const hasHero2 = !!hand.heroCards[0] && !!hand.heroCards[1];
  if(hasHero2){
    hand.btnLocked = true;

    // Switch table clicks to "select actor" mode
    if(loggerState && loggerState.table){
      loggerState.table.uiMode = "ACTOR";

      // Default selected actor = Hero position (seat 0)
      const nPlayers = Number(loggerState?.table?.maxPlayers || 8);
      const posBySeat = buildSeatPositionsFromButton(Number(hand.btnSeat), nPlayers);
      loggerState.table.selectedActorPos = posBySeat[0] || "HERO";
    }
  }

  saveLogger();
  renderLoggerTable();
  renderLoggerHandEditor(hand);
  renderLoggerHandsList();
}

  });
});

heroLine.appendChild(heroLabel);
heroLine.appendChild(heroVal);
heroLine.appendChild(heroBtn);
top.appendChild(heroLine);


// Board block
const boardLine = document.createElement("div");
boardLine.style.display = "flex";
boardLine.style.gap = "10px";
boardLine.style.flexWrap = "wrap";
boardLine.style.alignItems = "center";

const boardLabel = document.createElement("div"); 
boardLabel.style.fontWeight = "950";
boardLabel.textContent = "Board";

const b = hand.board || {flop:[null,null,null], turn:null, river:null};
const boardPretty =
  `${cardToPretty(b.flop?.[0])} ${cardToPretty(b.flop?.[1])} ${cardToPretty(b.flop?.[2])}  |  ${cardToPretty(b.turn)}  |  ${cardToPretty(b.river)}`;

const boardVal = document.createElement("div");
boardVal.className = "kicker";
boardVal.style.fontWeight = "900";
boardVal.textContent = boardPretty;

const boardBtn = document.createElement("button");
boardBtn.textContent = "Pick board";
boardBtn.addEventListener("click", ()=>{
  const cur = hand.board || {flop:[null,null,null], turn:null, river:null};
  const slots = [
    cur.flop?.[0] || null,
    cur.flop?.[1] || null,
    cur.flop?.[2] || null,
    cur.turn || null,
    cur.river || null
  ];
  const heroExclude = new Set(allPickedCards(hand.heroCards || []));
openLoggerCardPicker({
  title: "Pick board",
  sub: "Pick flop (3), then turn (1), then river (1).",
  slots,
  exclude: heroExclude,
  onSave: (newSlots)=>{
    hand.board = {
      flop: [newSlots[0]||null, newSlots[1]||null, newSlots[2]||null],
      turn: newSlots[3]||null,
      river: newSlots[4]||null
    };
    saveLogger();
    renderLoggerHandEditor(hand);
    renderLoggerHandsList();
  }
});

});

boardLine.appendChild(boardLabel);
boardLine.appendChild(boardVal);
boardLine.appendChild(boardBtn);
top.appendChild(boardLine);

const boardReadout = document.createElement("div");
boardReadout.className = "kicker";
boardReadout.style.color = "var(--muted)";
boardReadout.style.fontWeight = "900";
boardReadout.style.marginTop = "6px";
renderBoardSummaryInto(boardReadout, hand, (hand.viewMode || "LOG"));
top.appendChild(boardReadout);


// Actions block
const actionsWrap = document.createElement("div");
actionsWrap.style.display = "grid";
actionsWrap.style.gap = "10px";
actionsWrap.style.marginTop = "8px";

const actionsTitle = document.createElement("div");
actionsTitle.className = "kicker";
actionsTitle.style.color = "var(--muted)";
actionsTitle.style.fontWeight = "900";
actionsTitle.textContent = "Actions (street-by-street)";

const modeRow = document.createElement("div");
modeRow.style.display = "flex";
modeRow.style.gap = "8px";
modeRow.style.alignItems = "center";

function mkModeBtn(label, mode){
  const b = document.createElement("button");
  b.type = "button";
  b.textContent = label;
  b.style.padding = "8px 10px";
  b.style.borderRadius = "12px";
  b.style.fontWeight = "900";
  b.style.opacity = (hand.viewMode || "LOG") === mode ? "1" : ".55";
  b.addEventListener("click", ()=>{
    hand.viewMode = mode;
    saveLogger();
    renderLoggerHandEditor(hand);
  });
  return b;
}

modeRow.appendChild(mkModeBtn("Log", "LOG"));
modeRow.appendChild(mkModeBtn("Review", "REVIEW"));
actionsWrap.appendChild(modeRow);


const form = document.createElement("div");
form.style.display = "grid";
form.style.gridTemplateColumns = "repeat(6, minmax(0, 1fr))";
form.style.gap = "8px";
form.style.alignItems = "end";

function mkSelect(options, value){
  const s = document.createElement("select");
  s.style.width = "100%";
  s.style.borderRadius = "12px";
  s.style.border = "1px solid rgba(255,255,255,.10)";
  s.style.background = "rgba(0,0,0,.18)";
  s.style.color = "var(--text)";
  s.style.padding = "10px 12px";
  s.style.fontWeight = "800";
  for(const opt of options){
    const o = document.createElement("option");
    o.value = opt.value;
    o.textContent = opt.label;
    s.appendChild(o);
  }
  s.value = value;
  return s;
}

function mkInput(placeholder, value){
  const i = document.createElement("input");
  i.type = "text";
  i.placeholder = placeholder || "";
  i.value = value || "";
  i.style.width = "100%";
  i.style.borderRadius = "12px";
  i.style.border = "1px solid rgba(255,255,255,.10)";
  i.style.background = "rgba(0,0,0,.18)";
  i.style.color = "var(--text)";
  i.style.padding = "10px 12px";
  i.style.fontWeight = "800";
  return i;
}

const nPlayers = Number(loggerState?.table?.maxPlayers || 8);
const posBySeatLocal = buildSeatPositionsFromButton(Number(hand.btnSeat), nPlayers);

// Build list of positions in seat order (seat 0 = Hero)
const posOptions = [];
for(let seat = 0; seat < nPlayers; seat++){
  const pos = posBySeatLocal[seat] || `P${seat+1}`;
  const label = seat === 0 ? `${pos} (Hero)` : pos;
  posOptions.push({ value: pos, label });
}

// Form controls
const streetSel = mkSelect(
  [
    {value:"PREFLOP", label:"Preflop"},
    {value:"FLOP", label:"Flop"},
    {value:"TURN", label:"Turn"},
    {value:"RIVER", label:"River"}
  ],
(loggerState?.table?.lastStreet || "PREFLOP")

);

const nextStreetBtn = document.createElement("button");
nextStreetBtn.textContent = "Next street →";
nextStreetBtn.style.padding = "10px 12px";
nextStreetBtn.style.borderRadius = "12px";
nextStreetBtn.style.fontWeight = "900";
nextStreetBtn.type = "button";

function advanceStreet(){
  const order = ["PREFLOP","FLOP","TURN","RIVER"];
  const cur = streetSel.value;
  const idx = order.indexOf(cur);
  if(idx >= 0 && idx < order.length - 1){
    const next = order[idx + 1];
    streetSel.value = next;

    if(loggerState && loggerState.table){
      loggerState.table.lastStreet = next;
    }

    saveLogger();
    renderLoggerHandEditor(hand);
  }
}

nextStreetBtn.addEventListener("click", advanceStreet);


const defaultActor =
  (loggerState?.table?.selectedActorPos && posOptions.some(o => o.value === loggerState.table.selectedActorPos))
    ? loggerState.table.selectedActorPos
    : (posOptions[0]?.value || "HERO");

const actorSel = mkSelect(posOptions, defaultActor);

// Keep table-selected actor in sync if user changes dropdown manually
actorSel.addEventListener("change", ()=>{
  if(loggerState && loggerState.table){
    loggerState.table.selectedActorPos = actorSel.value;
    saveLogger();
    renderLoggerTable();
  }
});


const actionSel = mkSelect(
  [
    {value:"FOLD", label:"Fold"},
    {value:"CHECK", label:"Check"},
    {value:"CALL", label:"Call"},
    {value:"BET", label:"Bet"},
    {value:"RAISE", label:"Raise"},
    {value:"ALLIN", label:"All-in"}
  ],
  (loggerState?.table?.lastAction || "CALL")
);


const amtInput = mkInput("Amount", "");

function updateAmtPlaceholder(){
  const act = String(actionSel.value || "").toUpperCase();
  if(act === "RAISE" || act === "CALL"){
    amtInput.placeholder = "To (bb)";
  } else if(act === "BET"){
    amtInput.placeholder = "Bet (bb)";
  } else if(act === "ALLIN"){
    amtInput.placeholder = "All-in (bb)";
  } else {
    amtInput.placeholder = "Amount";
  }
}

updateAmtPlaceholder();
actionSel.addEventListener("change", updateAmtPlaceholder);

  
  const unitSel = mkSelect(
  [
    {value:"BB", label:"BB"},
    {value:"MONEY", label:getActiveSessionMeta().currency || "$"}
  ],
  "BB"
);

const noteInput = mkInput("Note (optional)", "");

/* ===== Fast templates (use existing form controls + existing hand.actions model) ===== */
const tplRow = document.createElement("div");
tplRow.style.display = "flex";
tplRow.style.gap = "6px";
tplRow.style.flexWrap = "wrap";
tplRow.style.margin = "6px 0 2px";

let __lastAddedActionId = null;

function needsAmount(action){
  const k = String(action || "")
    .trim()
    .toUpperCase()
    .replace(/[^A-Z0-9]/g, ""); // "3-bet" -> "3BET"

  // Actions that should prompt amount entry
  return (
    k === "BET" ||
    k === "RAISE" ||
    k === "ALLIN" ||
    k === "OPEN" ||
    k === "3BET"
  );
}


function parseBetSize(raw){
  if(!raw) return null;

  const s = String(raw).trim().toLowerCase();

  // "pot", "full pot"
  if(s === "pot" || s === "full pot") return { type:"POT", value:1 };

  // "1/2 pot", "0.5 pot"
  let m = s.match(/^(\d*\.?\d+)\s*(?:\/)?\s*pot$/);
  if(m) return { type:"POT", value: Number(m[1]) };

  // "50%", "33 %"
  m = s.match(/^(\d*\.?\d+)\s*%$/);
  if(m) return { type:"PERCENT", value: Number(m[1]) };

  // pure number → BB
  if(!isNaN(s)) return { type:"BB", value:Number(s) };

  return null;
}

  
  function setForm(street, action){
  streetSel.value = street;
  actionSel.value = action;

  // If this action type needs amount, focus it for fast entry
  if(needsAmount(action)){
    setTimeout(()=> amtInput.focus(), 0);
  } else {
    amtInput.value = "";
  }
}

function addActionQuick(street, action, presetAmt){
  if(!Array.isArray(hand.actions)) hand.actions = [];

  const id = String(Date.now()) + "_" + Math.random().toString(16).slice(2);

  const obj = {
    id,
    street,
    actorPos: actorSel.value || (posOptions[0]?.value || "HERO"),
    action,
    amt: (needsAmount(action) ? (presetAmt ?? "") : ""),
    unit: unitSel.value || "BB",
    note: "",
    createdAt: Date.now()
  };

obj.norm = parseBetSize(obj.amt);
hand.actions.push(obj);

  __lastAddedActionId = id;

saveLogger();
renderActionsList();

if(loggerState && loggerState.table){
  loggerState.table.lastStreet = street;
  loggerState.table.lastAction = action;
  loggerState.table.selectedActorPos = obj.actorPos;
}

  
  // Force focus for sizing actions (Open / 3-bet / Bet / Raise / All-in)
if(needsAmount(action)){
  setTimeout(()=>{
    amtInput.focus();
    try { amtInput.select(); } catch(e){}
  }, 0);
}


  // Scroll + flash the new row (renderActionsList patch below adds data-aid)
  setTimeout(()=>{
    const row = list.querySelector(`[data-aid="${id}"]`);
    if(row){
      row.classList.add("loggerActionFlash");
      row.scrollIntoView({block:"nearest", behavior:"smooth"});
      setTimeout(()=> row.classList.remove("loggerActionFlash"), 650);
    }
  }, 0);

  // Prefill form for “next action” speed
  setForm(street, action);
}

function mkTpl(label, street, action, presetAmt){
  const b = document.createElement("button");
  b.type = "button";
  b.className = "pfBtn";
  b.textContent = label;
  b.addEventListener("click", ()=> addActionQuick(street, action, presetAmt));
  return b;
}

// Street-aware templates (compact: only a few buttons + More dropdown)
function renderQuickTemplates(){
  tplRow.innerHTML = "";

  const st = streetSel.value || "PREFLOP";

  // Per-street “most used” quick buttons
  if(st === "PREFLOP"){
    tplRow.appendChild(mkTpl("Fold", "PREFLOP", "FOLD"));
    tplRow.appendChild(mkTpl("Call", "PREFLOP", "CALL"));
    tplRow.appendChild(mkTpl("Raise", "PREFLOP", "RAISE"));
  } else {
    tplRow.appendChild(mkTpl("Check", st, "CHECK"));
    tplRow.appendChild(mkTpl("Bet",   st, "BET"));
    tplRow.appendChild(mkTpl("Raise", st, "RAISE"));
    tplRow.appendChild(mkTpl("Fold",  st, "FOLD"));
  }

  // “More…” dropdown (keeps UI clean)
  const moreSel = document.createElement("select");
  moreSel.style.borderRadius = "12px";
  moreSel.style.border = "1px solid rgba(255,255,255,.10)";
  moreSel.style.background = "rgba(0,0,0,.18)";
  moreSel.style.color = "var(--text)";
  moreSel.style.padding = "10px 12px";
  moreSel.style.fontWeight = "900";
  moreSel.style.minWidth = "120px";

  const opts = [
    {v:"", label:"More…"},
    {v:"CALL",  label:"Call"},
    {v:"CHECK", label:"Check"},
    {v:"BET",   label:"Bet"},
    {v:"RAISE", label:"Raise"},
    {v:"FOLD",  label:"Fold"},
    {v:"ALLIN", label:"All-in"},
  ];

  // Preflop doesn’t use “Check” in most logging; still allow via More if you want,
  // but keep the quick row clean.
  if(st === "PREFLOP"){
    // (leave all options; it’s fine)
  }

  for(const o of opts){
    const op = document.createElement("option");
    op.value = o.v;
    op.textContent = o.label;
    moreSel.appendChild(op);
  }

  moreSel.addEventListener("change", ()=>{
    if(!moreSel.value) return;
    addActionQuick(st, moreSel.value);
    moreSel.value = "";
  });

  // "Checks around" (postflop only)
  if(st !== "PREFLOP"){
    const checksBtn = document.createElement("button");
    checksBtn.textContent = "Checks around";
    checksBtn.className = "pfBtn";
    checksBtn.type = "button";
    checksBtn.addEventListener("click", addChecksAround);
    tplRow.appendChild(checksBtn);
  }

  
  tplRow.appendChild(moreSel);
}

renderQuickTemplates();
streetSel.addEventListener("change", renderQuickTemplates);

/* ===== /Fast templates ===== */

function addChecksAround(){
  const st = streetSel.value;
  if(st === "PREFLOP") return;

  const actions = ensureHandActions(hand);

  const nPlayers = Number(loggerState?.table?.maxPlayers || 8);
  const btnSeatLocal = Number(hand.btnSeat != null ? hand.btnSeat : loggerState?.table?.btnSeat || 0);
  const posBySeat = buildSeatPositionsFromButton(btnSeatLocal, nPlayers);

  const activeSeats = [];

  for(let i=0;i<nPlayers;i++){
    const pos = posBySeat[i];
    const folded = actions.some(a => a.actorPos === pos && a.action === "FOLD");
    if(!folded){
      activeSeats.push(pos);
    }
  }

  activeSeats.forEach(pos=>{
    actions.push({
      id: uidShort(),
      createdAt: Date.now(),
      street: st,
      actorPos: pos,
      action: "CHECK",
      unit: "BB",
      amt: 0,
      note: "",
      norm: null
    });
  });

  saveLogger();
  advanceStreet();
}

  
  
// Add button
const addBtn = document.createElement("button");
addBtn.textContent = "Add";
addBtn.style.width = "100%";

addBtn.addEventListener("click", ()=>{
  const meta = getActiveSessionMeta();
  const unit = unitSel.value;
  const rawAmt = String(amtInput.value || "").trim();

  const amtNum = rawAmt === "" ? 0 : Number(rawAmt);
  if(rawAmt !== "" && !isFinite(amtNum)){
    toast("Amount must be a number");
    return;
  }

  const actions = ensureHandActions(hand);

const a = {
  id: uidShort(),
  createdAt: Date.now(),
  street: streetSel.value,
  actorPos: actorSel.value,
  action: actionSel.value,
  unit,
  amt: amtNum,
  note: String(noteInput.value || "").trim()
};

a.norm = parseBetSize(a.amt);

actions.push(a);

// Persist form defaults for speed
if(loggerState && loggerState.table){
  loggerState.table.lastStreet = a.street;
  loggerState.table.lastAction = a.action;
  loggerState.table.selectedActorPos = a.actorPos;
}


  saveLogger();
  renderLoggerHandEditor(hand);
  renderLoggerHandsList();
});

const streetWrap = document.createElement("div");
streetWrap.style.display = "grid";
streetWrap.style.gridTemplateColumns = "1fr auto";
streetWrap.style.gap = "8px";
streetWrap.appendChild(streetSel);
streetWrap.appendChild(nextStreetBtn);

// then in your form append order:
form.appendChild(streetWrap);
form.appendChild(actorSel);
form.appendChild(actionSel);
form.appendChild(amtInput);
form.appendChild(unitSel);
form.appendChild(addBtn);


// Actions list
const list = document.createElement("div");
list.style.display = "flex";
list.style.flexDirection = "column";
list.style.gap = "6px";

function renderActionsList(){
  list.innerHTML = "";
  const meta = getActiveSessionMeta();
  const actions = ensureHandActions(hand);

  if(!actions.length){
    const empty = document.createElement("div");
    empty.className = "kicker";
    empty.style.color = "var(--muted)";
    empty.textContent = "No actions yet. Add preflop actions first (open, 3bet, fold, etc.).";
    list.appendChild(empty);
    return;
  }

  actions.forEach((a, idx)=>{
    const row = document.createElement("div");
    row.dataset.aid = a.id || "";
    row.style.display = "grid";
    row.style.gridTemplateColumns = "1.2fr 1.2fr 1fr 1fr 2fr 70px";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    row.style.padding = "8px 10px";
    row.style.borderRadius = "12px";
    row.style.border = "1px solid rgba(255,255,255,.08)";
    row.style.background = "rgba(255,255,255,.03)";

    const street = document.createElement("div");
    street.className = "kicker";
    street.style.fontWeight = "900";
    street.textContent = a.street;

    const who = document.createElement("div");
    who.className = "kicker";
    who.style.fontWeight = "900";
    who.textContent = a.actorPos;

    const act = document.createElement("div");
    act.className = "kicker";
    act.style.fontWeight = "900";
    act.textContent = a.action;

    const amt = document.createElement("div");
    amt.className = "kicker";
    amt.style.fontWeight = "900";

    if(a.amt && a.amt !== 0){
      if(a.unit === "MONEY"){
        amt.textContent = fmtMoney(meta.currency, a.amt);
      }else{
        amt.textContent = `${a.amt}bb`;
      }
    }else{
      amt.textContent = "—";
    }

    const note = document.createElement("div");
    note.className = "kicker";
    note.style.color = "var(--muted)";
    note.textContent = a.note ? a.note : "";

    const del = document.createElement("button");
    del.textContent = "Del";
    del.style.padding = "8px 10px";
    del.addEventListener("click", ()=>{
      actions.splice(idx, 1);
      saveLogger();
      renderLoggerHandEditor(hand);
      renderLoggerHandsList();
    });

    row.appendChild(street);
    row.appendChild(who);
    row.appendChild(act);
    row.appendChild(amt);
    row.appendChild(note);
    row.appendChild(del);

    list.appendChild(row);
  });
}

renderActionsList();

actionsWrap.appendChild(actionsTitle);
actionsWrap.appendChild(tplRow);
if((hand.viewMode || "LOG") === "LOG"){
  actionsWrap.appendChild(form);
  actionsWrap.appendChild(list);
} else {
  // REVIEW mode
  const meta = getActiveSessionMeta();
  const actions = getSortedActions(hand);


  const streets = ["PREFLOP","FLOP","TURN","RIVER"];
  const streetLabel = {PREFLOP:"Preflop", FLOP:"Flop", TURN:"Turn", RIVER:"River"};

  const wrap = document.createElement("div");
  wrap.style.display = "grid";
  wrap.style.gap = "12px";

  // ===== Replay controls =====
const replay = document.createElement("div");
replay.style.display = "grid";
replay.style.gap = "8px";
replay.style.padding = "10px 12px";
replay.style.borderRadius = "16px";
replay.style.border = "1px solid rgba(255,255,255,.10)";
replay.style.background = "rgba(255,255,255,.03)";

const replayTop = document.createElement("div");
replayTop.style.display = "flex";
replayTop.style.justifyContent = "space-between";
replayTop.style.alignItems = "center";
replayTop.style.gap = "10px";

const replayLabel = document.createElement("div");
replayLabel.className = "kicker";
replayLabel.style.fontWeight = "950";
replayLabel.textContent = "Replay";

const replayNow = document.createElement("div");
replayNow.className = "kicker";
replayNow.style.color = "var(--muted)";
replayNow.style.fontWeight = "900";

const total = actions.length;
let idx = Number(hand.replayIdx || 0);
if(!isFinite(idx) || idx < 0) idx = 0;
if(idx > Math.max(0, total - 1)) idx = Math.max(0, total - 1);
hand.replayIdx = idx;

function updateReplayNow(){
  if(!total){
    replayNow.textContent = "No actions logged yet.";
    return;
  }
  const a = actions[hand.replayIdx];
  replayNow.textContent = `(${hand.replayIdx + 1}/${total}) ${a.street} • ${a.actorPos} • ${a.action}`;
}

updateReplayNow();

replayTop.appendChild(replayLabel);
replayTop.appendChild(replayNow);

const replayBtns = document.createElement("div");
replayBtns.style.display = "flex";
replayBtns.style.flexWrap = "wrap";
replayBtns.style.gap = "8px";

function mkReplayBtn(label, onClick){
  const b = document.createElement("button");
  b.type = "button";
  b.textContent = label;
  b.style.padding = "8px 10px";
  b.style.borderRadius = "12px";
  b.style.fontWeight = "900";
  b.addEventListener("click", onClick);
  return b;
}

replayBtns.appendChild(mkReplayBtn("Start", ()=>{
  hand.replayIdx = 0;
  saveLogger();
  renderLoggerHandEditor(hand);
}));
replayBtns.appendChild(mkReplayBtn("Prev", ()=>{
  hand.replayIdx = Math.max(0, (hand.replayIdx||0) - 1);
  saveLogger();
  renderLoggerHandEditor(hand);
}));
replayBtns.appendChild(mkReplayBtn("Next", ()=>{
  hand.replayIdx = Math.min(Math.max(0, total - 1), (hand.replayIdx||0) + 1);
  saveLogger();
  renderLoggerHandEditor(hand);
}));
replayBtns.appendChild(mkReplayBtn("End", ()=>{
  hand.replayIdx = Math.max(0, total - 1);
  saveLogger();
  renderLoggerHandEditor(hand);
}));

replay.appendChild(replayTop);
replay.appendChild(replayBtns);

// Put replay panel above the street cards
wrap.appendChild(replay);
// ===== /Replay controls =====


  const nPlayers = Number(loggerState?.table?.maxPlayers || 8);
  const posBySeat = buildSeatPositionsFromButton(Number(hand.btnSeat), nPlayers);
  const heroPos = posBySeat[0] || "HERO";

  let globalIdx = 0;
 
  streets.forEach(st=>{
    const group = actions.filter(x => x.street === st);
    if(!group.length) return;

    const card = document.createElement("div");
    card.style.border = "1px solid rgba(255,255,255,.10)";
    card.style.borderRadius = "16px";
    card.style.background = "rgba(255,255,255,.03)";
    card.style.padding = "10px 12px";

    const h = document.createElement("div");
    h.className = "kicker";
    h.style.fontWeight = "950";
    h.textContent = streetLabel[st] || st;

    const ul = document.createElement("div");
    ul.style.display = "grid";
    ul.style.gap = "6px";
    ul.style.marginTop = "8px";

    group.forEach(a=>{
      const line = document.createElement("div");
      line.className = "kicker";
      line.style.fontWeight = "850";
      line.style.padding = "6px 8px";
      line.style.borderRadius = "12px";
      line.style.border = "1px solid rgba(255,255,255,.08)";
      line.style.background = "rgba(0,0,0,.10)";
      line.textContent = fmtActionLine(meta, a);

      // Highlight the replay cursor line
      if(globalIdx === Number(hand.replayIdx || 0)){
        line.style.outline = "2px solid rgba(255,255,255,.35)";
        line.style.boxShadow = "0 0 0 3px rgba(255,255,255,.10)";
      }
      globalIdx++;

      
      if(a.actorPos === heroPos){
        line.style.border = "1px solid rgba(0,255,160,.35)";
        line.style.boxShadow = "0 0 0 3px rgba(0,255,160,.08)";
      }

      ul.appendChild(line);
    });

    card.appendChild(h);
    card.appendChild(ul);
    wrap.appendChild(card);
  });

  actionsWrap.appendChild(wrap);
}


// Add this block into your editor UI
mount.appendChild(actionsWrap);

  
  const notes = document.createElement("textarea");
  notes.style.width = "100%";
  notes.style.minHeight = "110px";
  notes.style.borderRadius = "12px";
  notes.style.border = "1px solid rgba(255,255,255,.10)";
  notes.style.background = "rgba(0,0,0,.18)";
  notes.style.color = "var(--text)";
  notes.style.padding = "10px 12px";
  notes.style.fontWeight = "700";
  notes.value = hand.notes || "";

  notes.addEventListener("input", ()=>{
    hand.notes = notes.value;
    saveLogger();
  });

  top.appendChild(title);
  top.appendChild(meta);
  top.appendChild(notesLabel);
  top.appendChild(notes);

  mount.appendChild(top);
}
// end of renderloggerhandeditor

function createLoggerHand(){
  const active = getActiveSession();
  if(!active){
    toast("Create/select a session first");
    return;
  }

      const hand = {
      id: uid(),
      createdAt: Date.now(),
      viewMode: "LOG",
      replayIdx: 0,
      maxPlayers: Number(loggerState?.table?.maxPlayers || 8),
      heroSeat: 0,
      btnSeat: Number(loggerState.table.btnSeat),
      notes: "",
    
      // NEW
heroCards: [null, null], // exactly 2

board: {
  flop: [null, null, null], // exactly 3
  turn: null,               // 1
  river: null               // 1
},

actions: [] // [{id, street, actorPos, action, amt, unit, toCall, note, createdAt}]

    };
    
    
      active.hands = active.hands || [];
      active.hands.unshift(hand);
      loggerSelectedHandId = hand.id;
    
      if(loggerState && loggerState.table){
      loggerState.table.uiMode = "BTN";
      loggerState.table.selectedActorPos = null;
      loggerState.table.lastStreet = "PREFLOP";
      loggerState.table.lastAction = "CALL";
    }

  
      saveLogger();
      renderLoggerSessionSummary();
      renderLoggerHandsList();
      renderLoggerHandEditor(hand);

      // Auto-open hero card picker for new hands
      openLoggerCardPicker({
        title: "Pick hero cards",
        sub: "Select exactly 2 cards.",
        slots: hand.heroCards.slice(),
        exclude: new Set([
          ...(hand.board?.flop || []),
          hand.board?.turn || null,
          hand.board?.river || null
        ].filter(Boolean)),
        onSave: (newSlots)=>{
          hand.heroCards = [newSlots[0] || null, newSlots[1] || null];
          saveLogger();
          renderLoggerHandEditor(hand);
          renderLoggerHandsList();
        }
      });

    
      toast("Hand created");
}

                             
function setMode(mode){
  const isExplorer = mode === "explorer";
  const isTrainer  = mode === "trainer";
  const isLogger   = mode === "logger";

  explorerView.style.display = isExplorer ? "grid" : "none";
  trainerView.style.display  = isTrainer  ? "grid" : "none";
  if(loggerView) loggerView.style.display = isLogger ? "grid" : "none";

  // Button labels
  modeBtn.textContent = isTrainer ? "Back to explorer" : "Trainer mode";
  if(loggerBtn) loggerBtn.textContent = isLogger ? "Back to explorer" : "Hand logger";

  setTopControlsForMode(mode);

  
  if(isTrainer){
    startQuestion();
  }

  if(isExplorer){
    renderScenario(scenarioSel.value);
    updateSelectedHandPanel(scenarioSel.value);
    renderPostflopAdvice();
  }

if(isLogger){
  renderLoggerSessions();
  refreshLoggerUI();
  renderLoggerTable();
}



}

function setTopControlsForMode(mode){
  const scenarioEl = document.getElementById("scenario");
  const personaEl = document.getElementById("persona");
  const toggleLabelsBtn = document.getElementById("toggleLabels");
  const copyBtn = document.getElementById("copy");

  const isLogger = mode === "logger";

  if(scenarioEl) scenarioEl.style.display = isLogger ? "none" : "";
  if(personaEl) personaEl.style.display = isLogger ? "none" : "";
  if(toggleLabelsBtn) toggleLabelsBtn.style.display = isLogger ? "none" : "";
  if(copyBtn) copyBtn.style.display = isLogger ? "none" : "";

  // Ensure nav order: Back to Explorer leftmost, then Trainer, then Help
  const controlsWrap = document.querySelector(".controls");
  if(controlsWrap && loggerBtn && modeBtn && helpBtn){
    controlsWrap.appendChild(loggerBtn);
    controlsWrap.appendChild(modeBtn);
    controlsWrap.appendChild(helpBtn);
  }
}


                             
  modeBtn.addEventListener("click", ()=>{
    const isTrainer = trainerView.style.display !== "none";
    setMode(isTrainer ? "explorer" : "trainer");
  });

if(loggerBtn){
  loggerBtn.addEventListener("click", ()=>{
    const isLogger = loggerView && loggerView.style.display !== "none";
    setMode(isLogger ? "explorer" : "logger");
  });
}

if(loggerNewSessionBtn){
  loggerNewSessionBtn.addEventListener("click", ()=>{
    createLoggerSession();
  });
}

if(loggerSessionSel){
  loggerSessionSel.addEventListener("change", ()=>{
    loggerState.activeSessionId = loggerSessionSel.value || null;
    loggerSelectedHandId = null; // <-- ADD THIS
    saveLogger();
    renderLoggerSessions();
    refreshLoggerUI();
    renderLoggerTable();
  });
}



const loggerNewHandBtn = document.getElementById("loggerNewHand");

if(loggerNewHandBtn){
  loggerNewHandBtn.addEventListener("click", ()=>{
    createLoggerHand();
  });
}

function resetSelectedHandUI(){
  selHand.textContent = "—";
  selAct.textContent = "—";
  selNote.textContent = "Click a cell";

  const selDeltaEl = document.getElementById("selDelta");
  if(selDeltaEl) selDeltaEl.textContent = "—";
  if(selHandAwareness) selHandAwareness.textContent = "Pick a flop and click Apply.";
}


  
  function openHelp(){
    helpModal.style.display = "block";
    document.body.style.overflow = "hidden";
  }
  function closeHelp(){
    helpModal.style.display = "none";
    document.body.style.overflow = "";
  }

  if(helpBtn){
    helpBtn.addEventListener("click", openHelp);
  }
  if(helpClose){
    helpClose.addEventListener("click", closeHelp);
  }
  if(helpBackdrop){
    helpBackdrop.addEventListener("click", closeHelp);
  }
  window.addEventListener("keydown", (e)=>{
    if(e.key === "Escape" && helpModal && helpModal.style.display !== "none") closeHelp();
  });

  trainerNextBtn.addEventListener("click", ()=> startQuestion());
  trainerScenarioSel.addEventListener("change", ()=> startQuestion());
  trainerRandomness.addEventListener("change", ()=> startQuestion());

// Persona change (single source of truth)
if (personaSel) {
  personaSel.addEventListener("change", () => {
    savePersona();

    // Clear cached ranges so persona changes take effect everywhere
    for (const k in cache) delete cache[k];

    // Clear selected-hand panel + delta so nothing stale persists
    resetSelectedHandUI();

    // Re-render explorer
    renderScenario(scenarioSel.value);
    renderPostflopAdvice(); // <-- ADD THIS

    
    // Refresh trainer question if trainer is open
    if (trainerView.style.display !== "none") startQuestion();
  });
}



  
  btnRaise.addEventListener("click", ()=> submit("R"));
  btnCall.addEventListener("click", ()=> submit("C"));
  btnFold.addEventListener("click", ()=> submit("F"));

// Postflop board apply (from selected flop slots)
if(boardApplyBtn){
  boardApplyBtn.addEventListener("click", ()=>{
    const cards = flopSelToBoard();
    if(!cards){
      toast("Pick 3 cards first");
      return;
    }
   currentBoard = {
  flop: cards,
  turn: null,
  river: null
};

toast("Board applied");
renderPostflopAdvice();

// NEW: update the hand awareness panel immediately
renderExplorerHandAwareness();

  });
}


  
  trainerReset.addEventListener("click", ()=>{
    session.correct = 0; session.total = 0; session.streak = 0;
    saveSession();
    renderStats();
    toast("Session reset");
  });

  trainerClearHistory.addEventListener("click", ()=>{
    session.missed = [];
    saveSession();
    renderStats();
    toast("Missed list cleared");
  });

// Initial render
loadPersona(); // must be before renderScenario
loadLogger();  // <-- ADD THIS
renderScenario(scenarioSel.value);
renderPostflopAdvice();
populateTrainerScenarios();
loadSession();
renderStats();

// If you refresh while in logger (rare), you can re-render it safely
if(loggerView && loggerView.style.display !== "none"){
  renderLoggerTable();
}


</script>
</body>
</html>

